# URL 단축기 설계 정리

---

## 1. 문제 이해 및 설계 범위 확정

- **쓰기 연산**: 매일 1억 개의 단축 URL을 생성  
  → 초당 쓰기 연산: `1억 / (24*3600) ≒ 1160`

- **데이터 저장 규모**:  
  서비스 10년간 운영 가정 → 총 레코드 수:  
  `1억 * 365 * 10 = 3650억 개`  
  원본 URL 평균 길이: 100 byte  
  → 저장 용량: `3650억 * 100 byte = 36.5 TB`

- **읽기 연산**:  
  읽기와 쓰기의 비율을 10:1로 가정하면 초당 읽기 요청은 약 11,600회 발생

---

## 2. 개략적 설계안 및 API 엔드포인트

URL 단축기는 기본적으로 두 가지 기능을 제공해야 합니다.

### 2.1. URL 단축용 엔드포인트

- **용도**:  
  클라이언트가 원본 URL을 전송하면 단축 URL을 생성 및 반환
- **API 예시**:  
  [POST] /api/v1/data/shorten Body: { "longUrl": "http://www.example.com/..." } Response: 201 Created | { "shortenUrl": "http://short.ly/abc1234" }

### 2.2. URL 리다이렉션 엔드포인트

- **용도**:  
  단축 URL에 대한 HTTP 요청을 원본 URL로 리다이렉트
- **API 예시**:  
  [GET] /api/v1/{shortUrl} Response: 302 Found (또는 상황에 따라 301 Moved Permanently)
- **리다이렉션 관련 HTTP 상태 코드**:
- **301 Moved Permanently**:
    - 영구적으로 이전되었음을 알림 → 브라우저 캐싱
    - 서버 부하 감소에 유리
- **302 Found**:
    - 일시적인 리다이렉션 → 매번 요청이 단축 URL 서버로 전달되어 트래픽 분석에 유리

---

## 3. URL 단축 설계의 핵심 포인트

### 3.1. 해시 함수 설계

URL 단축 시 원본 URL을 **7글자의 단축 URL**로 변환해야 하는데, 사용 가능한 문자는 `[0-9, a-z, A-Z]`로 총 **62개**입니다.

- **문자 수 계산**:  
  62^n ≥ 3650억 → n의 최소값은 7  
  (즉, 7자리면 약 3.5조개의 조합을 제공)

#### 접근 방식 1: 해시 후 충돌 해소

- **동작 방식**:
1. SHA-1, MD5 등 기존 해시 함수를 사용하여 해시 값을 생성한 후, 앞 7글자만 사용
2. DB에서 해당 해시(단축 URL)가 이미 존재하는지 확인
3. 충돌 시, 사전에 정의된 문자열(예: "a")를 원본 URL에 추가하고 재해싱 → 충돌 해소 반복
- **단점**:
- 매번 DB 조회가 필요 → 오버헤드 발생
- 블룸 필터를 활용하여 DB 조회 횟수를 줄일 수 있음

#### 접근 방식 2: Base-62 변환

- **동작 방식**:
1. 유일성 보장을 위해 별도의 ID 생성기(예: 7장 유일 ID 생성기)를 사용
2. 생성된 유일한 ID를 Base-62로 인코딩
3. 인코딩 결과를 단축 URL로 사용
- **특징**:
- 충돌 발생 가능성이 없음 (ID가 유일함)
- 단축 URL 길이가 **가변적** → ID 값이 커지면 길이가 늘어날 수 있음
- 보안상 다음 URL 예측 문제가 있을 수 있음 (ID가 1씩 증가할 경우)

|  비교 항목           | 해시 후 충돌 해소                    | Base-62 변환                        |
|-------------------|------------------------------------|-----------------------------------|
| 단축 URL 길이         | 고정 (예: 7글자)                        | 가변 (유일 ID의 크기에 따라 다름)           |
| 유일성 보장 여부       | 해시 충돌 가능성 존재, 충돌해소 필요             | 유일 ID 사용 → 충돌 없음                |
| DB 조회 오버헤드       | 충돌 체크 시 DB 조회 발생                  | 별도 DB 조회 없이 ID 변환 가능           |
| 보안 측면            | 해시 후 결과 → 다음 URL 예측 불가               | ID가 순차적일 경우 예측 가능               |

---

## 4. URL 단축기 상세 설계

### 4.1. 데이터 모델

- **테이블 구조**:
- **id** (PK)
- **shortUrl** (unique, 인덱스 생성)
- **longUrl**

- **저장소 고려 사항**:  
  데이터가 10년간 3650억 레코드에 달할 수 있으므로 RDB뿐 아니라, 샤딩, NoSQL, 분산 캐시(예: Redis) 등 확장성을 고려해야 함.

### 4.2. URL 단축 프로세스 (Base-62 변환 기준)

1. **Long URL 입력**: 클라이언트가 긴 URL 전송
2. **중복 확인**:
- DB에 해당 longUrl이 이미 존재하는지 확인 → 기존 단축 URL 반환
3. **새 단축 URL 생성**:
- 유일 ID 생성기를 통해 새로운 ID 생성
- 생성된 ID를 Base-62로 인코딩하여 단축 URL 생성
4. **DB 저장**:
- {id, shortUrl, longUrl} 정보를 DB에 저장
5. **반환**:
- 단축 URL 반환 및 클라이언트에 응답

### 4.3. URL 리다이렉션 프로세스

1. 사용자가 단축 URL에 접속
2. **캐시 조회**:
- 단축 URL을 key로 캐시(예: Redis)에서 longUrl 조회
3. **DB 조회 (캐시 미스 시)**:
- DB에서 shortUrl에 해당하는 longUrl 조회 후 캐시에 저장
4. **HTTP 리다이렉션**:
- `Location` 헤더에 longUrl 설정하여 301 또는 302 응답 전송

---

## 5. 최종 아키텍처 및 확장 고려사항

- **로드 밸런싱**:  
  웹 서버를 스케일 아웃하여 단축 URL 생성 및 리다이렉션 요청 처리

- **데이터베이스 확장**:  
  샤딩 또는 다중화 기법을 적용해 3650억 건의 데이터 저장 처리

- **캐시 전략**:  
  단축 URL 조회 시 look-aside 캐시 전략을 적용하여 DB 부하 감소

- **처리율 제한 (Rate Limiting)**:  
  DDoS나 악의적인 대량 요청을 방어하기 위해 IP 기반 필터링, API 게이트웨이 활용

- **트래픽 분석**:  
  302 응답 사용 시 매 요청 로그 수집 → 사용 패턴, 클릭률 분석 가능

---

## 7. 결론

URL 단축기는 단순해 보이지만, **대규모 트래픽**과 **거대한 저장 용량** 요구, 그리고 **보안** 및 **확장성** 측면에서 매우 까다로운 시스템입니다.  
두 가지 해시 전략(해시 후 충돌 해소 vs Base-62 변환) 각각의 장단점을 잘 이해하고, 상황에 맞는 설계를 선택하는 것이 중요합니다.  
리다이렉션 시 301과 302의 선택 역시 트래픽 분석, 캐시 정책, 보안 요구사항 등을 고려하여 결정해야 합니다.

이상의 내용은 공식 문서와 여러 실제 사례(예: Bitly, TinyURL 등)와 일치하며, 추가 학습 자료를 통해 심화 학습을 권장합니다.
