# 12장. 채팅 시스템 설계
## 목표
채팅 시스템을 설계하라.
## 1단계. 문제 이해 및 설계 범위 확정
- 종류: 일대일, 그룹 모두 지원
- 유형: 모바일 앱 & 웹 앱 모두 지원
- 트래픽 규모: DAU 5천만 명
- 그룹 채팅 인원 제한: 100명 이하
- 기능: 일대일 채팅, 그룹 채팅, 사용자 접속 상태 표시, 텍스트형 메시지
- 메세지 길이 제한: 100,000자 이하
- 종단 간 암호화: 후순위
- 채팅 이력 보관 기간: 영구적
### 요구사항
- 응답 지연 낮은 일대일 채팅 기능
- 최대 100명 그룹 채팅 기능
- 사용자 접속 상태 표시 기능
- 다양한 단말 지원, 하나의 계정으로 여러 단말 동시 접속
- 푸시 알림
## 2단계. 개략적 설계안 제시 및 동의 구하기
### 기본 기능
- 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자 접속 상태 아닌 경우 접속까지 메시지 보관

> HTTP는 클라이언트가 연결을 만드는 프로토콜로 메세지 전송 용도로는 괜찮지만, 서버에서 클라이언트로 임의 시점에 메시지를 수신하기에는 부적합하다.<br>
> 서버가 연결을 만드는 것처럼 동작할 수 있도록 폴링, 롱 폴링, 웹 소켓 등의 기술이 제안되어 왔다.

### 폴링
- 동작 방식
  - 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 물어보는 방법
- 문제점
  - 빈도에 따라 비용 증가
  - 메시지 없는 경우 서버 자원 낭비
### 롱폴링
- 폴링 개선
- 동작 방식
  - 연결 종료: 클라이언트에 새 메시지가 반환 or 타임아웃
  - 새로운 연결 수립: 기존 연결 종료 시 서버에 새로운 요청 보내 모든 절차 다시 시작
- 문제점
  - 메시지 전송 클라이언트와 수신 클라이언트가 다른 채팅 서버에 접속 가능성
    - HTTP 서버들은 무상태
    - 로드밸런싱을 위해 라운드 로빈 알고리즘 사용 시 메시지 받은 서버가 수신할 클라이언트와의 롱폴링 연결을 가지고 있지 않을 수 있다.
  - 서버 입장에서 클라이언트가 연결을 해제했는지 알 수 없음
  - 메시지 없는 클라이언트도 타임아웃마다 서버 다시 접속
### 웹소켓
- 서버가 클라이언트에게 비동기 메시지 보내는 기술
- 동작 방식
  - 클라이언트가 서버에 HTTP 핸드셰이크 시작
  - 웹 소켓 연결로 업그레이드
  - 항구적/양방향 연결 수립
- 메시지 송수신 시 동일 프로토콜 사용 가능
- 웹소켓 연결은 항구적이므로 서버 측에서 연결 관리를 효율적으로 해야함
### 개략적 설계안
- 규모 확장성
    - 서버 한 대로 얼마나 많은 동시 접속을 허용할 수 있는가
    - SPOF 문제 고려
- 무상태 서비스, 상태 서비스, 제3자 서비스 연동으로 구분

<img alt="image" src="https://github.com/user-attachments/assets/27cecc2c-4508-4fd6-a632-26a8ce30d88a">

<img alt="image" src="https://github.com/user-attachments/assets/66c55818-99b1-49b7-9c50-4499bb0b04b7">

### 데이터 모델
- 1:1 채팅을 위한 메시지 테이블
  - pk(message_id)기준 메시지 순서 지정
    - 고유
    - 정렬 가능
    - 시간 순서와 일치
- 그룹 채팅을 위한 메시지 테이블
  - pk(channel_id, message_id)
  - channel_id를 파티션 키로 사용
- 메시지 ID 생성 전략
  - 스노우플레이크
  - 지역적 순서 번호 생성기: "ID 유일성은 같은 그룹 안에서만 보증하면 충분하다"
## 3단계. 상세 설계
- 서비스 탐색
- 메시지 전달 흐름
- 사용자 접속 상태 표시 방법
### 1) 서비스 탐색
- 클라이언트에게 가장 적합한 채팅 서버 추천
- 기준: 클라이언트의 위치, 서버 용량 등
- 구현: 오픈 소스 솔루션(ex: 아파치 주키퍼) 사용
- 동작 방식
  - 사용자를 서비스할 최적의 채팅 서버를 탐색
  - 선택된 서버 정보를 반환
  - 클라이언트는 해당 서버와 웹소켓 연결 수립
### 2) 메시지 흐름
#### 1:1 채팅 & 여러 단말 사이 메시지 동기화
<img alt="image" src="https://github.com/user-attachments/assets/b89e5e66-7c50-4e9e-937e-277417a9430e">

#### 소규모 그룹 채팅

<img alt="image" src="https://github.com/user-attachments/assets/e305e6e9-2cdf-4718-ba44-d4bc7b427ed0">

### 3) 접속 상태 표시
- 사용자 로그인: 로그인 및 웹소켓 연결 수립 후 접속 상태 서버는 `{status: online, last_active_at: timestamp}`를 키-값 저장소에 보관
- 사용자 로그아웃: 로그아웃 후 `online -> offline`으로 갱신
- 접속 장애
  1. 사용자 접속 장애 시 오프라인으로 표시 후 복구 시 온라인 상태로 변경
     - 아주 짧은 시간 동안의 접속 장애로 인한 상태 변경은 사용자 경험 측면에서 바람직 X
  2. 박동 검사
     - 클라이언트에서 주기적으로 박동 이벤트를 접속 상태 서버로 전송
     - 설정한 n초 이내에 박동 이벤트가 오지 않으면 오프라인으로 변경
### 4) 상태 정보 전송
- 발행-구독 모델 사용
- 친구관계마다 채널 배치
- A의 접속상태 변경에 대해 B, C, D 사용자가 각 채널(A-B, A-C, A-D)을 구독
- 그룹 크기가 작을 때 효과적
## 4단계. 마무리
### 추가 고려사항
- 사진, 비디오 등 미디어 지원: 압축 방식, 클라우드 저장소, 섬네일 생성 논의
- 종단 간 암호화
- 캐시
- 로딩 속도 개선: 지역적으로 분산하는 네트워크 구축 등
- 오류 처리
  - 채팅 서버 오류: 채팅 서버 오류 시 다른 서버로 배정 및 재접속 유도
  - 메시지 재전송: 재시도, 큐 등
