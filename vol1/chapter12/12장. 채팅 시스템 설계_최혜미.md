# 챕터 12. 채팅 시스템 설계

## 1. 문제 이해 및 설계 범위 확정

### 채팅 앱 종류 및 요구사항
- **앱 유형**
    - 1:1 채팅 앱 (예: 페이스북 메신저, 왓츠앱)
    - 그룹 채팅 앱 (예: 슬랙, 디스코드)
- **대상 플랫폼**
    - 모바일 앱, 웹 앱 또는 둘 다
- **트래픽 규모**
    - 예: 일일 능동 사용자(DAU) 5천만명
- **그룹 채팅 인원 제한**
    - 최대 100명까지 지원
- **핵심 기능**
    - 응답 지연이 낮은 1:1 채팅
    - 최대 100명까지 참여 가능한 그룹 채팅
    - 사용자 접속 상태 표시 (online/offline)
    - 다양한 단말 지원 (한 계정으로 여러 단말 동시 접속)
    - 푸시 알림 기능
- **추가 요구사항**
    - 메시지 길이: 최대 100,000자 이하
    - 종단 간 암호화: 현재는 미지원 (추후 논의 가능)
    - 채팅 이력: 영구 보관

### 문제 이해를 위한 주요 질문
- 채팅은 1:1, 그룹 채팅, 또는 둘 다 지원하는가?
- 주로 어떤 기기(모바일, 웹)에서 사용할 것인가?
- 처리해야 하는 트래픽 규모는?
- 그룹 채팅 시 인원 제한은 어떻게 되는가?
- 종단 간 암호화가 필요한가?
- 채팅 이력은 얼마나 오래 보관할 것인가?

---

## 2. 개략적 설계안 (High-Level Design)

### 시스템 구성 요소
- **클라이언트**
    - 메시지 송수신 및 연결 유지
    - 웹소켓(WebSocket)을 통한 양방향 실시간 통신 추천
- **채팅 서비스 (Stateful Service)**
    - 클라이언트와 지속적 연결 (웹소켓) 유지
    - 메시지 중계 및 전달
- **무상태 서비스 (Stateless Service)**
    - 로그인, 회원가입, 사용자 프로필 등 일반 HTTP API 제공
    - 로드 밸런서를 통해 분산 처리
- **서비스 탐색 (Service Discovery)**
    - 클라이언트가 최적의 채팅 서버에 연결할 수 있도록 서버 정보 제공
    - 예: 아파치 주키퍼, 유레카 등
- **Third-Party 연동**
    - 푸시 알림 서비스 (챕터 10 참조)

### 통신 프로토콜 선택
- **메시지 송신**
    - HTTP (keep-alive 사용) 또는 웹소켓
- **메시지 수신**
    - **웹소켓(WebSocket)**:
        - 초기 HTTP 핸드셰이크 후 업그레이드
        - 항구적이며 양방향 통신 지원
    - **폴링(Polling) / 롱 폴링(Long Polling)**:
        - 비효율적(주기적 요청, 타임아웃 발생 시 재접속) → 웹소켓 선호

### 확장성 고려
- 동시 접속자가 많을 경우 (예: 1M 연결, 연결당 10KB 메모리 필요 → 약 10GB 메모리)
- 서버 단일화(SPOF) 문제를 피하기 위해 수평 확장 및 다중화 필요

---

## 3. 상세 설계

### 3.1 메시지 전달 흐름

#### 1:1 채팅 메시지 처리
1. **메시지 송신**
    - 사용자가 채팅 서버에 메시지 전송
    - 채팅 서버는 메시지 ID를 생성 (예: Snowflake, 로컬 시퀀스 등)
    - 메시지를 메시지 동기화 큐로 전송하고, 키-값 저장소에 저장
2. **메시지 전달**
    - **수신자 B가 온라인인 경우:**
        - B와 연결된 채팅 서버(웹소켓)로 즉시 전달
    - **수신자 B가 오프라인인 경우:**
        - 푸시 알림 서버로 전달하여 B가 접속 시 메시지 수신

#### 다중 단말 메시지 동기화
- 각 단말은 `cur_max_message_id` 변수를 유지
- 새 메시지의 `message_id`가 단말의 `cur_max_message_id`보다 크면 새 메시지로 간주

#### 그룹 채팅 메시지 처리
- 그룹 채팅의 경우, 한 메시지를 그룹에 속한 모든 사용자별로 메시지 큐에 복사
- 소규모 그룹(최대 100명)에서는 복사 오버헤드가 크지 않음
- 대규모 그룹의 경우 별도 최적화 필요 (예: 메시지 브로드캐스트 방식)

### 3.2 사용자 접속 상태 표시
- **접속 상태 서버**
    - 클라이언트가 웹소켓 연결을 맺으면, 해당 사용자의 상태를 `online`으로 기록 (키-값 저장소 사용)
    - 로그아웃 시 `offline`으로 상태 변경
- **Heartbeat (박동) 시스템**
    - 클라이언트는 주기적으로(예: 5초마다) 박동 이벤트 전송
    - 일정 시간(예: 30초) 동안 박동 미수신 시, 자동으로 `offline` 처리
- **상태 정보 전송**
    - 발행-구독(Pub/Sub) 모델을 통해 친구들에게 상태 업데이트 전파
    - 소규모 그룹에서는 각 친구마다 별도의 채널, 대규모 그룹은 주기적/수동 갱신 고려

### 3.3 저장소 및 데이터 모델

#### 저장소 선택
- **일반 데이터 (사용자 프로필, 설정, 친구 목록)**
    - 관계형 데이터베이스(RDBMS) 사용
- **채팅 이력 데이터**
    - 키-값 저장소(NoSQL) 사용
    - 이유:
        - 데이터 양이 방대함
        - 최근 메시지에 대한 빠른 접근 필요
        - 수평 확장성 및 낮은 지연 시간

#### 데이터 모델 예시

- **1:1 채팅 메시지 테이블 (Message)**
    - `message_id` (bigint, 기본키)
    - `message_from` (bigint)
    - `message_to` (bigint)
    - `content` (text)
    - `created_at` (timestamp)

- **그룹 채팅 메시지 테이블 (Group Message)**
    - `channel_id` (bigint)
    - `message_id` (bigint, 복합키)
    - `message_to` (bigint)
    - `content` (text)
    - `created_at` (timestamp)

#### 메시지 ID 생성
- 전역적으로 유일하고, 시간 순 정렬이 가능한 ID 생성 (예: Snowflake, 로컬 시퀀스)

---

## 4. 추가 고려 사항 및 보완점

- **미디어 파일 지원**
    - 이미지, 비디오 파일: 압축, 클라우드 스토리지, 섬네일 생성 등 추가 고려
- **종단 간 암호화 (End-to-End Encryption)**
    - 초기에는 필요하지 않으나, 보안 강화 시 도입 가능
- **캐시 및 로딩 속도 개선**
    - 이미 읽은 메시지를 캐시하여 서버 부하 감소 및 응답 속도 개선
- **오류 처리 및 메시지 재전송**
    - 채팅 서버 장애 시 서비스 탐색을 통해 새로운 서버로 재접속
    - 메시지 재전송(큐, 재시도) 메커니즘 구현

---

## 5. 마무리 및 요약

### 핵심 목표
- **실시간 채팅 지원:**
    - 낮은 응답 지연의 1:1 및 그룹 채팅
- **사용자 경험 강화:**
    - 다중 단말 동시 접속, 사용자 접속 상태 표시, 푸시 알림
- **높은 확장성:**
    - 수평 확장, 분산 아키텍처 (서비스 탐색, 로드 밸런싱, 키-값 저장소 활용)

### 주요 구성 요소
- **채팅 서버:**
    - 메시지 중계 및 웹소켓 연결 유지
- **접속 상태 서버:**
    - Heartbeat를 통한 사용자 상태 관리
- **API 서버:**
    - 로그인, 회원가입, 프로필 관리 등 무상태 서비스 제공
- **푸시 알림 서버:**
    - 오프라인 사용자 대상 알림 전송
- **저장소:**
    - RDBMS (일반 데이터)와 NoSQL 키-값 저장소 (채팅 이력)

### 확장 및 최적화 포인트
- 서비스 탐색(예: 주키퍼)을 통한 최적의 채팅 서버 할당
- 메시지 큐를 이용한 안정적 메시지 전달 및 동기화
- 캐시 및 분산 저장소를 통한 빠른 데이터 접근
- Heartbeat 시스템을 이용한 사용자 접속 상태 정확도 개선

