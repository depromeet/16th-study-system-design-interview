## 12장 채팅 시스템 설계

### 개요
- 면접관이 생각하고 있는게 일대일 채팅 앱일 때 그룹 채팅 앱을 설계하면 곤란하다
- 기능 요구사항을 확실히 알아두자

### 문제 이해 및 설계 범위 확정
- 일대일 인지, 그룹 채팅 앱인지
- 모바일인지, 웹 앱인지
- 처리해야하는 트래픽의 규모 DAU
- 그룹 채팅의 인원 제한이 있는지
- 중요 기능 (첨부 파일, 접속 상태 등)
- 메시지 길이 제한
- 종단 암호화 지원 여부
- 채팅 이력 보관 기간

### 클라이언트-서버 간 통신 방법에 대한 고민
- 클라이언트는 직접 통신하지 않는다
- 클라이언트는 채팅 서비스와 통신한다
- 어떤 프로토콜을 사용할지도 중요한 문제
  - HTTP는 널리 사용되는 프로토콜
  - keep-alive 헤더를 사용하면 클라이언트-서버간 연결을 끊지 않고 유지한다
  - 하지만 서버가 임의 시점에 클라이언트에게 메시지를 보낼 수 없다
  - 폴링, 롱폴링, 웹소켓 등의 방법이 있음
- 폴링
  - 클라이언트가 주기적으로 서버에게 요청
  - 서버 자원이 불필요하게 낭비 된다
- 롱폴링
  - 새 메시지가 반환 되거나 타임아웃 될 때까지 연결을 유지함
  - 단, 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버가 아닐 가능성이 있음
  - 서버 입장에서 클라이언트의 연결 해제 여부를 알 수 없음
  - 여전히 비효율적
- 웹소켓
  - 비동기 메시지를 보낼 때 널리 사용하는 기술
  - 한번 맺어진 연결은 항구적으로 양방향이다
  - 방화벽이 있는 환경에서도 잘 동작하는데 HTTP나 HTTPS 프로토콜이 사용하는 기본 포트 번호를 그대로 사용하기 때문
  - 구현도 단순하고 직관적이지만 서버에서 연결 관리를 효율적으로 해야함

### 개략적 설계안
- 상태 유지 서비스: 유일하게 상태 유지가 필요한 서비스는 채팅 서비스
  - 각 클라이언트와 채팅 서버와 독립적인 네트워크 연결을 유지해야하기 때문
- 제 3자 서비스 연동: 새 메시지를 받았다면 앱이 실행 중이지 않더라도 알림을 받아야 한다
- 규모 확장성
  - 서버 한 대로 얼마나 많은 동시 접속을 허용할 수 있는가
  - 동시 접속자 1M, 접속당 10k 메모리가 필요하면 => 10GB 메모리
  - SPOF 발생 지점이 되지만, 점차 다듬어 갈것을 말하자

### 저장소
- 채팅 시스템이 다루는 데이터는 보통 두가지
  - 사용자 프로파일, 친구 목록 같은 일반적인 데이터
  - 엄청난 양의 채팅 이력, 오래된 메시지는 잘 들여다 보지 않음
- 키 값 저장소를 추천함
  - 수평적 규모 확장이 쉽다
  - 접근 지연 시간이 낮다
  - RDMBS는 인덱스가 커지면 데이터에 대한 무작위 접근을 처리하는 비용이 늘어난다
  - 이미 많은 채팅 시스템이 키 값 저장소를 채택하고 있음

### 데이터 모델
- 1:1 채팅을 위한 메시지 테이블
- 그룹 채팅을 위한 메시지 테이블
- 메시지 ID
  - message_id는 고유해야함
  - 정렬 가능하고 시간 순서와 일치해야함
  - nosql은 해당 기능을 제공하지 않음 => 스노플레이크 같은 생성기를 이용하자

### 상세 설계
- 서비스 탐색
- 메시지 전달 흐름
- 사용자 접속 상태 표시 방법

### 서비스 탐색
- 클라이언트에게 적합한 채팅 서버를 추천하는 것
- 클라이언트 위치, 서버의 용량을 기준으로 판단
- 아파치 주키퍼 같은 오픈소스 솔루션이 있ㄹ음

### 메시지 흐름
- 1:1 채팅 메시지 흐름
  1. 채팅 서버1로 메시지 전송
  2. ID 생성기로 메시지 ID 결정
  3. 메시지 동기화 큐로 전송
  4. 키 값 저장소에 메시지 보관
  5. 푸시 알림 서버로 전송
  6. 웹소켓 연결을 통해 사용자에게 전송
- 여러 단말 사이의 동기화
  - cur_max_message_id라는 변수 이용하는데, 가장 최근 메시지 ID를 추척하는 용도
- 소규모 그룹 채팅에서의 메시지 흐름
  - 사용자 A,B,C의 각각의 메시지 큐에 복사되는데, 개인 메시지 수신함의 개념
  - 그룹이 크지 않으면, 각 메시지 큐에 넣는 비용이 큰 문제가 되지 않음

### 접속 상태 표시
- 접속 상태 서버는 웹소켓을 통신하는 실시간 서비스의 일부다
- 사용자가 로그인 하면 웹 소켓 연결이 맺어지고 키값 저장소에 타임스탬프 값을 보관
- 로그아웃하면 오프라인으로 사용자 상태가 변경
- 인터넷 연결 문제로 접속 장애가 발생할 수 있다 (ex. 터널 지나가는 등)
  - 박동 검사를 통해 문제를 해결할 수 있는데, 주기적으로 박동 이벤트를 서버로 보내도록 한다
- 그룹 크기가 작을 때 발행-구독 모델 사용해, 친구 관계마다 구독하여 상태 정보를 알게 하자

### 추가 논의해보면 좋은 것
- 압축방식, 클라우드 저장소, 썸네일 생성 등
- 종단 감 암호화: 발신인 수신자 외에 아무도 메시지 내용을 보지 못하도록 함
- 캐시
- 로딩 속도 개선
- 오류 처리: 채팅 서버 오류, 메시지 재전송 등