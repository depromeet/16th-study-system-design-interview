## 6장 키-값 저장소 설계

### 키 값 저장소란
- 키-값 데이터베이스라고도 불리는 비관계형 데이터베이스
- 성능상의 이유로 키는 짧을 수록 좋음
- 값은 무엇이든 올 수 있다

### 단일 서버 키-값 저장소
- 전부를 메모리에 해시 테이블로 저장함
- 빠른 속도를 보장하지만 모든 데이터를 두는 것이 불가능할 수도 있다
- 이를 해결하기 위해 데이터 압축, 데이터를 디스크에 저장하는 방법 있음
- 결국 서버 한 대로 부족한 때가 온다

### 분산 키-값 저장소
- 분산 해시 테이블이라고도 불림
- CAP 정리를 이해하고 있어야 하는데, 이는 일관성, 가용성, 파티션 감내를 모두 만족시키기 어렵다는 것이다
- **데이터 일관성**: 어떤 노드에 접속하든 같은 데이터를 보아야한다
- **데이터 가용성**: 일부 노드에 장애가 발생해도 데이터를 응답 받아야 한다
- **파티션 감내**: 네트워크에 파티션이 생겨 통신 장애가 발생해도, 시스템은 계속 동작해야 한다
- 이 세 가지 중 두 가지만 만족시키는 것이 일반적이다
  - **CP**: 일관성과 파티션 감내를 만족시키는 것
  - **AP**: 가용성과 파티션 감내를 만족시키는 것
  - **CA**: 일관성과 가용성을 만족시키는 것. 하지만 네트워크 장애는 피할 수 없으므로 실세계에 존재하지 않음

### 실세계의 분산 시스템
- 분산 시스템에서는 파티션 문제를 피할 수 없다
- 일관성과 가용성 사이에서 하나를 택해야함
- n1, n2, n3 세 노드가 있을 때, n3에 장애가 발생하면
  - **CP**: n1, n2의 쓰기 연산을 중단시켜야함
  - **AP**: 낡은 데이터를 반환할 수 있음
- 요구사항에 맞게 시스템을 설계해야한다

### 대규모 파티션
- 데이터를 파티션 단위로 나누어 저장할 때 두가지를 따져봐야하는데
  - 데이터를 서버에 고르게 분산할 수 있는가
  - 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가
- 5장의 안정 해시가 이를 해결하는 방법이다
- 안정 해시를 사용해 데이터를 파티션 하면 
  - 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제 되게 만들 수 있다
  - 각 서버 용량에 맞게 가상 노드를 조정할 수 있다

### 데이터 다중화
- 데이터를 N개 서버에 비동기적으로 다중화 할 필요가 있음
- 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터를 복사하는 것이 한가지 방법
- 가상 노드가 많다면, 실제 복사되는 물리 서버의 개수가 작아지기 때문에, 중복 선택하지 않도록 해야함

### 데이터 일관성
- 정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산을 수행할 때 일관성을 보장할 수 있음
  - N = 사본 개수
  - W = 쓰기 연산을 수행할 때 필요한 사본 개수
  - R = 읽기 연산을 수행할 때 필요한 사본 개수
- W + R > N 이면 강한 일관성을 보장할 수 있다, 최신 데이터 노드가 최소 하나는 겹치니까
- W + R <= N 이면 강한 일관성이 보장되지 않음
- R=1, W=N : 빠른 읽기 연산에 적합
- W=1, R=N : 빠른 쓰기 연산에 적합

### 일관성 모델
- 강한 일관성에서는 클라이언트는 절대 낡은 데이터를 보지 못하고, 약한 일관성에서는 최근에 갱신된 데이터를 반환하지 못할 수도 있다
- 결과적 일관성은, 갱신 결과가 결국에는 모든 사본에 반영된다는 모델
- 강한 일관성을 달성하는 방법은 쓰기 연산 결과가 반영 될 때까지 읽기/쓰기를 금지하는 것 (고가용성 시스템에는 부적합)
- 결과적 일관성에서 쓰기가 병렬적으로 발생하면 일관성이 깨질 수 있는데, 이는 클라이언트가 해결해야함
- 비 일관성을 해소 하는 기법으로 데이터 버저닝이 있는데, 데이터를 변경할 때마다 새로운 버전을 만드는 것이다
  - 벡터 시계는 이 문제를 해결하는데 보편적으로 사용 됨. 
  - 서버, 버전의 순서쌍을 데이터에 매달아, 선행 후행 버전을 판별하는 것이다. (충돌 여부를 쉽게 판단할 수 있음)
  - 단, 충돌 감지 및 해소 로직으로 인해 클라이언트 구현이 복잡해지고, 순서쌍의 개수가 빨리 증가한다.

### 장애 처리
- 분산 시스템에서는 두 대 이상의 서버가 특정 서버의 장애를 보고해야, 해당 서버를 장애로 간주한다
- 멀티캐스팅 채널을 구축하는 것이 장애 감지에 효과적이나, 서버가 많을 때는 비효율적이다.
- 따라서 가십 프로토콜(gossip protocol)같은 분산형 장애 감지 솔루션이 효율적이다
- 각 노드는 주기적으로 자신의 박동 카운터를 증가시키고, 어떤 멤버의 박통 카운터 값이 지정된 시간 동안 갱신되지 않으면, 장애로 간주
- 일시적인 장애를 처리하기 위해 엄격한 정족수(읽기 쓰기 연산 금지), 또는 느슨한 정족수(대신 수행할 서버를 해시링에서 고름) 접근법을 사용할 수 있다
- 영구적인 장애는 반-엔트로피 프로토콜을 구현해 사본을 동기화한다. (머클 트리를 사용해 데이터의 일관성을 검증)

