# **채팅 시스템 설계**

## **1. 문제 이해 및 설계 범위 확정**
### **채팅 시스템 개요**
- 페이스북 메신저, 왓츠앱, 디스코드와 같은 **실시간 채팅 서비스**
- 1:1 채팅과 그룹 채팅을 모두 지원
- 클라이언트(모바일, 웹) 간 실시간 메시지 교환을 가능하게 함

### **요구 사항**
- **지원 플랫폼**: 모바일(iOS, Android) 및 웹
- **핵심 기능**:
    - 1:1 채팅 및 그룹 채팅 (최대 100명)
    - 사용자의 접속 상태 표시
    - 여러 단말에서 동시 접속 지원
    - 푸시 알림 (앱이 실행 중이지 않아도 메시지 수신 가능)
- **트래픽 규모**:
    - 하루 5천만 명의 활성 사용자(DAU)
    - 동시 접속자 100만 명
- **메시지 길이 제한**: 최대 100,000자
- **채팅 이력 보관**: 영구 저장

---

## **2. 개략적 설계**
### **클라이언트-서버 통신 방식**
- **메시지 송신**: HTTP 프로토콜 사용
- **메시지 수신**: 실시간 처리를 위해 **웹소켓(WebSocket)** 사용

### **웹소켓을 이용한 통신 방식**
- **Polling**: 클라이언트가 주기적으로 서버에 요청 → 비효율적
- **Long Polling**: 메시지가 도착할 때까지 서버가 응답을 대기 → 개선되었지만 여전히 비효율적
- **WebSocket**: 양방향 지속 연결 유지, 비동기 메시지 전송 가능 → 최적의 선택

### **시스템 구성**
- **무상태 서비스**: 로그인, 회원가입, 사용자 프로필 관리 (HTTP 기반)
- **상태 유지 서비스**: 채팅 서버(웹소켓 연결 유지)
- **제3자 서비스 연동**: 푸시 알림 지원

<img width="500" alt="image" src="https://github.com/user-attachments/assets/0d66b9ac-4228-442b-b6b4-e7cc21664462" />

### **채팅 서버 주요 기능**
1. 클라이언트로부터 **메시지 수신**
2. **수신자 결정 및 전달**
3. 수신자가 오프라인인 경우 **메시지 저장 후 푸시 알림 전송**


<img width="500" alt="image" src="https://github.com/user-attachments/assets/2904064d-ec27-4f8b-aab6-41642c0c727e" />

---

## **3. 데이터 저장 및 확장성**
### **데이터베이스 선택**
- **관계형 DB(RDBMS) vs NoSQL**
    - **사용자 정보**: 관계형 DB (MySQL, PostgreSQL)
    - **채팅 이력**: **NoSQL (HBase, Cassandra, Redis)** 사용

### **읽기/쓰기 패턴 분석**
- **메시지 데이터 양이 매우 큼** → 하루 600억 개 메시지 처리 필요
- **대부분의 사용자는 최근 메시지만 조회** → 캐시 활용
- **일부 사용자는 특정 메시지를 검색** → 색인(index) 필요

### **키-값 저장소 기반 데이터 모델**
#### **1:1 채팅 메시지 저장**
- `message_id`를 **기본 키(Primary Key)** 로 사용하여 메시지 순서 보장
- `created_at`으로 정렬하여 빠르게 최신 메시지 조회

#### **그룹 채팅 메시지 저장**
- **(channel_id, message_id) 복합 키(Composite Key) 사용**
- `channel_id`를 **파티션 키(Partition Key)** 로 사용하여 샤딩 가능

---



## **4. 상세 설계**
### **서비스 탐색 (Service Discovery)**
- 클라이언트가 최적의 채팅 서버에 연결하도록 도와주는 기능
- 기준: **지리적 위치, 서버 부하 상태 등**
- **Apache Zookeeper** 같은 솔루션 활용

<img width="478" alt="image" src="https://github.com/user-attachments/assets/14ca0577-396c-4950-ae13-5dd197ad028f" />

### **메시지 흐름**
#### **1:1 채팅 메시지 전송 과정**
1. A 사용자가 채팅 서버에 메시지 전송
2. 채팅 서버에서 메시지 ID 생성
3. 메시지를 **메시지 동기화 큐(Message Sync Queue)** 로 전송
4. 키-값 저장소(Key-Value Store)에 메시지 저장
5. B 사용자가 **온라인**이면 B의 채팅 서버로 메시지 전송
6. B 사용자가 **오프라인**이면 푸시 알림 발송

<img width="601" alt="image" src="https://github.com/user-attachments/assets/8df4241f-d3a6-422a-8a35-cd3defcbd2fe" />

#### **여러 단말 간 메시지 동기화**
- 단말별 최신 메시지 ID(`cur_max_message_id`) 유지
- 키-값 저장소에서 새로운 메시지만 조회하여 동기화 수행

<img width="400" alt="image" src="https://github.com/user-attachments/assets/009b3879-670c-425e-b660-8a75151b4e54" />

#### **그룹 채팅 메시지 흐름**
- **소규모 그룹(예: 500명 이하)**: 각 사용자마다 메시지 큐를 생성하여 복사 저장
  - <img width="400" alt="image" src="https://github.com/user-attachments/assets/f04c057f-9fa8-46d4-b893-8faf9fe6195c" />
- **대규모 그룹(예: 수만 명 이상)**: 메시지 복사 비용이 커지므로 큐 대신 중앙 저장 방식 사용
  - <img width="400" alt="image" src="https://github.com/user-attachments/assets/2f74a80c-74dd-417d-9c63-5906359c8d14" />
---

## **5. 사용자 접속 상태 관리**
### **접속 상태 표시**
- **접속 상태 서버(Presence Server)** 사용
- **로그인 시**: 웹소켓 연결이 완료되면 `online` 상태 저장
- **로그아웃 시**: `offline` 상태로 변경
- **네트워크 장애 감지**:
    - **Heartbeat**(주기적인 상태 확인 메시지) 사용
    - 일정 시간(`X`초) 내 새로운 Heartbeat 메시지가 없으면 `offline` 처리

### **접속 상태 전송**
- **Pub-Sub 모델** 활용하여 친구들에게 상태 변화 전파
- **작은 그룹**: 채널을 생성하여 구독하는 방식 적용
- **대규모 그룹**: 성능 최적화를 위해 사용자가 직접 상태 조회

---


## **6. 확장성 및 최적화 고려 사항**
### **데이터베이스 확장**
- **수직적 확장 vs 수평적 확장**: 트래픽 증가에 대비하여 샤딩(Sharding) 고려
- **Master-Slave 복제**를 이용한 읽기 부하 분산

### **캐싱 전략**
- 데이터베이스 부하 감소를 위해 **Redis, Memcached 활용**
- **가장 최근 메시지만 캐싱**하여 응답 속도 최적화

### **메시지 큐 도입**
- **비동기 메시지 처리**를 위해 Kafka, RabbitMQ 사용
- 서버 장애 발생 시 **메시지 재전송(Retry)** 메커니즘 적용

### **보안 및 속도 개선**
- **JWT 토큰 인증**을 통한 보안 강화
- 트래픽이 많을 경우 **전송률 제한(Rate Limiting)** 적용
- **멀티 데이터센터 운영**으로 지연(latency) 감소

---

## **7. 결론**
- **웹소켓 기반의 실시간 채팅 시스템 설계**
- **Pub-Sub 모델을 활용한 접속 상태 관리**
- **혼합형 메시지 전달 방식(Fan-out on Write & Fan-out on Read) 적용**
- **Redis, NoSQL, 메시지 큐(Kafka) 활용한 확장성 보장**
- **푸시 알림을 통한 사용자 경험 개선**

채팅 시스템의 설계를 설명할 때는 **트래픽 처리, 실시간성, 확장성, 최적화 전략**을 중심으로 논의하는 것이 중요하다.
