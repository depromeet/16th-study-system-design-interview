# 10장 - 실시간 게임 순위표
## 1단계 - 문제 이해 및 설계 범위 확정
- 요구 사항 분석
    - Q) 순위표의 점수는 어떻게 계산하나요?
        - A) 사용자가 경기에서 승리하면 포인트를 얻고 이 포인트로 점수를 계산함. 경기에서 이길 때마다 1점의 포인트를 얻음
    - Q) 모든 플레이어가 순위표에 포함되는가?
        - A) yes
    - Q) 한 순위표는 얼마 동안 유효한가?
        - A) 매달 새로운 토너먼트 시작 시 순위표도 새로 만듦
    - Q) 상위 10명만 신경 써도 되는가?
        - A) 상위 10명과 특정 사용자의 순위를 순위표에 표시함. 시간이 되면 어떤 사용자보다 4순위 위/아래 사용자 반환 방법도 논의함
    - Q) 토너먼트 참가자 수는?
        - A) DAU는 500만 명, MAU는 2500만 명으로 함
    - Q) 토너먼트 기간 동안 평균 몇 경기가 진행되는가?
        - A) 각 선수는 하루 평균 10경기를 진행함
    - Q) 동점은 어떻게 처리 하는가?
        - A) 같은 순위로 처리함. 시간이 되면 동점 사이 우선 순위를 가르는 방법을 얘기해봄
    - Q) 순위표는 실시간인가?
        - A) 실시간 혹은 최대한 실시간에 가깝게 결과를 표시함. 누적된 결과 이력은 바람직하지 않음

### 기능 요구사항
- 순위표 상위 10명 표시
- 특정 사용자 표시
- 어떤 사용자의 4순위 위/아래 표시(보너스)

### 비기능 요구사항
- 점수 업데이트는 실시간으로 순위표에 반영
- 일반적인 확장성, 가용성 및 안정성 요구사항

### 개략적 규모 추정
- 약 초당 50명의 사용자가 게임을 플레이함
    - 사용자가 24시간 고르게 분포할 경우 DAU가 500만명일 때 초당 약 50명의 사용자가 게임을 플레이함
- 최대 부하는 평균의 5배라고 가정
    - 사용자가 고르게 분포하기 보다는 특정 시간대에 몰리기 때문임
- 따라서 초당 최대 250명의 사용자를 감당할 수 있어야 함
- 사용자 점수 획득 QPS
    - 2500
    - 하루 평균 10개로 가정하고, QPS는 약 500(50 * 10)임
    - 최대 QPS는 5배로 가정했으므로 2500임
- 상위 10명 순위표 가져오기 QPS
    - 약 50
    - 각 사용자가 하루 한 번 게임을 열고 상위 10명 순위표를 처음 게임 열 때만 표시한다고 가정함

## 2단계 - 개략적 설계안 제시 및 동의 구하기
### API 설계 - POST /v1/scores
- 사용자가 게임에서 승리하면 순위표에서 사용자 순위를 갱신
- 게임 서버에서만 호출할 수 있는 내부 API임
- 사용자는 이 API를 통하지 않고 직접 점수 업데이트할 수 없다
- 매개변수
    - user_id : 게임에서 승리한 사용자
    - points : 사용자가 얻은 포인트
- 응답
    - 200 OK : 점수 업데이트 성공
    - 400 Bad Request : 인자가 잘못 전달되어 점수 갱신이 안된 경우

### API 설계 - GET /v1/scores
- 상위 10명의 플레이어 목록
- 응답 예제
```json
{
  "data": [
    {
      "user_id": "user1",
      "user_name": "alice",
      "rank": 1,
      "score": 1000
    },
    {
      "user_id": "user2",
      "user_name": "bob",
      "rank": 2,
      "score": 977
    },
    ...
  ]
}

```

### API 설계 - GET /v1/scores/{user_id}
- 특정 사용자의 순위
- 응답 예제
```json
{
  "user_info": {
    "user_id": "user5",
    "user_name": "mike",
    "rank": 17,
    "score": 870
  }
}
```

### 개략적 설계안
- 두 가지 서비스가 포함
    - 게임 서비스
        - 게임을 플레이하는 데 사용되는 서비스
    - 순위표 서비스
        - 순위표를 생성하고 표시하는 서비스
- 매커니즘
    - 사용자가 게임을 승리하면 클라이언트는 게임 서비스에 요청을 보냄
    - 게임 서비스는 해당 승리의 정당성과 유효성을 확인 후 순위표 서비스에 점수 갱신을 요청
    - 순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신
    - 해당 사용자의 클라리언트는 순위표 서비스에 직접 요청해 상위 10명과 해당 사용자의 순위를 가져옴

### 클라이언트가 순위표 서비스와 직접 통신해야 하는가?
- 클라이언트가 점수를 정하는 것은 사용자가 프록시를 설치하고 점수를 마음대로 바꾸는 중간자 공격을 할 수 있기에 보안상 위험함
- 온라인 포커처럼 서버가 게임 전반을 통솔할 경우에는 게임 서버를 명시적으로 호출할 필요가 없을 수도 있음

### 게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?
- 게임 점수가 어떻게 사용되는지에 따라 달라짐
- 다른 곳에서도 이용되거나 여러 기능을 지원해야 할 경우 카프카에 데이터를 넣는 것이 합리적일 수 있음
    - 순위표 서비스, 분석 서비스, 푸시 알림 서비스 등 여러 소비자가 다양한 데이터를 사용할 경우 메시지 큐를 사용하는 것이 좋음
    - 다른 플레이어에게 점수가 바뀌었음을 알려야 하는 순번제(턴제) 게임이나 멀티플레이 게임의 경우 더욱 그럼
- 일단 본 설계안에서는 요청 사항이 없으므로 포함하지 않음

### 데이터 모델 - RDB
- 규모 확장성이 그다지 중요하지 않고 사용자 수가 많지 않은 경우
- 각 월별 순위표는 사용자 ID와 점수 열을 갖는 DB 테이블로 표현할 수 있음
- 승리자가 신규 유저일 경우 1점을 주고, 기존 사용자인 경우 원래 점수에 1점을 추가함
- 순위의 경우 테이블을 점수 기준으로 내림차순 정렬하면 됨
    - 순위는 매번 계산할 필요가 없고, 점수만 갱신하면 됨
- 점수를 딴 경우
    - 새로운 사용자인 경우
        - INSERT INTO leaderboard (user_id, score) VALUES ({user_id}, 1)
    - 이미 존재하는 사용자인 경우
        - UPDATE leaderboard SET score = score + 1 WHERE user_id = {user_id}
- 특정 사용자 순위 검색
    - SELECT (@rownum := @rownum + 1) as rank, user_id, score FROM leaderboard ORDER BY score DESC
- 데이터가 적을 땐 좋지만, 레코드가 많아지면 성능이 매우 떨어짐
- 순위 파악을 위해서는 모든 플레이어가 순위표의 정확한 위치에 정렬되어야 함
- 같은 점수를 받는 사용자가 여럿일 수 있으므로 순위는 단순히 해당 목록 내의 사용자의 위치라고 할 수 없음
- SQL DB는 지속적으로 변화하는 대량의 정보를 신속하게 처리하지 못 함
    - 수백만 개의 레코드에 순위를 매기려면 대략 수십 초가 걸리므로 실시간성을 요구하는 경우 적합하지 않음
- 데이터가 지속적으로 변경되기에 캐시 도입도 불가능함
- RDB는 본 시스템에 요구되는 다량의 [읽기 부하](#쓰기-작업아닌가..)를 처리하기 어려움
- 일괄 작업으로 수행하면 RDB로 가능할 수도 있지만, 실시간 요구사항에 부적합함
- index를 추가하고 LIMIT를 사용하는 할 수도 있음
    - SELECT (@rownum := @rownum + 1) as rank, user_id, score FROM leaderboard ORDER BY score DESC LIMIT 10
    - 규모 확장성이 좋지 않음
    - 전체 테이블을 스캔해야하므로 성능 하락
    - 순위표 상단에 있지 않은 사용자를 찾기 어려움

### 레디스
- 메모리 기반 key-value 저장소
- 빠른 읽기 쓰기가 가능함
- 이상적인 정렬 집합(sorted set) 자료구조를 제공함
- 순위표 구현에 필요한 레디스 연산
    - ZADD
        - 기존에 없던 사용자를 집합에 삽입, 기존 사용자는 점수 업데이트.
        - 실행 시간은 O(log n)
    - ZINCRBY
        - 사용자 점수를 지정된 값만큼 증가(신규 유저는 0부터 시작한다고 가정)
        - 실행 시간은 O(log n)
    - ZRANGE/ZREVERANGE
        - 점수에 따라 정렬된 사용자 중 특정 범위의 사용자를 조회
        - 순서, 항목 수, 시작 위치를 지정 가능
        - 실행 시간은 O(log n + m)
        - m은 가져올 항목 수, n은 정렬 집합의 크기
    - ZRANK.ZREVERANK
        - 오름차순/내림차순 정렬 시 특정 사용자의 위치
        - 실행 시간은 O(log n)
- 정렬 집합을 사용한 구현의 동작 원리
    - 사용자가 점수를 획득한 경우
        - 매월 새로운 정렬 집합을 만들고 이전 순위표는 이력 데이터 저장소로 보냄
        - 게임 승리 시 ZINCRBY를 호출해 점수를 증가시키거나 사용자를 순위표 집합에 추가함
            - ZINCRBY <키> <증분> <사용자>
    - 사용자가 순위표 상위 10명을 조회하는 경우
        - 가장 높은 점수를 받은 사용자부터 내림차순 정렬한 결과를 가져옴
        - 사용자 목록과 각 사용자의 점수도 가져와야하므로 WITHSCORES 속성도 전달
            - ZRANGE leaderboard_feb_2021 0 9 WITHSCORES
    - 사용자가 자기 순위를 조회하는 경우
        - ZREVRANK leaderboard_feb_2021 <user_id>
    - 특정 사용자 순위를 기준으로 일정 범위 내 사용자를 질의하는 경우
        - ZREVERANGE leaderboard_feb_2021 {앞범위} {뒷범위}

### 정렬 집합이란?
- 집합과 유사한 자료형임
- 각 원소는 점수에 연결되어 있음
- 집합 내 원소는 고유해야하지만 같은 점수는 있을 수도 있다
- 점수는 정렬 집합 내 오름차순 정렬에 사용됨
- 내부적으로 해시 테이블과 스킵 리스트라는 두가지 자료 구조를 사용함
    - 해시 테이블은 사용자 점수를 저장하기 위해, 스킵 리스트는 특정 점수를 딴 사용자들의 목록을 저장하기 위해
    - 스킵 리스트는 빠른 검색을 가능하게 하는 자료 구조임
        - 정렬된 연결 리스트에서 다단계 색인을 두는 구조.
            - 삽입, 삭제, 검색 연산을 실행하는 시간은 O(n)임
            - 이를 빠르게 하기 위해서는 이진 탐색처럼 하는 방법이 있음
            - 중간 노드를 하나씩 건너뛰는 1차 색인과 1차 색인을 건너뛰는 2차 색인을 추가함
            - 새로운 색인이 추가될 때마다 이전 차수의 노드를 하나씩 건너 뛸 수 있음
            - 노드 사이 거리가 n-1이 되면 색인을 더 이상 추가하지 않음
            - n은 노드의 총 개수
        - 정렬 집합은 삽입이나 갱신 연산 시 모든 원소가 올바른 위치에 자동으로 배치됨
        - 원소 추가나 검색이 O(log n)임
        - 이는 RDB보다 성능이 좋음. RDB에서는 특정 사용자 순위를 계산하려면 중첩 질의문을 실행해야 함
            - SELECT *, (SELECT COUNT(*) FROM leaderboard lb2 WHERE lb2.score >= lb1.score) as rank FROM leaderboard lb1 WHERE lb1.user_id = {user_id}

### 저장소 요구사항
- 최소한 사용자 ID와 점수는 저장해야함
- 최악은 DAU 모든 사용자가 한 번 이상 승리해서 모두 순위에 올라가는 경우임
    - ID는 24자 문자열, 점수가 16비트 정수일 경우 한 항목당 26바이트가 필요함
    - 26바이트 * 2500만 = 6억 5000만 바이트 약 650MB의 저장 공간이 레디스에 필요함
- CPU 및 I/O 사용량도 고려해야함.
    - 최대 QPS가 2500이므로 단일 레디스로 충분히 감당 가능함
- 영속성은 문제가 될 수 있음
    - 레디스는 노드 장애가 발생할 수 있기 때문임
    - 레디스는 데이터를 디스크에 영속적으로 저장하는 옵션을 지원함.
    - 다만, 디스크에서 데이터를 읽어 대규모 레디스 인스턴스 재시작에는 시간이 매우 오래 걸림
    - 그래서 보통 레디스에 읽기 사본을 두는 식으로 구성함
        - 주 서버에 장애 발생 시 읽기 사본을 승격시켜서 사용함


## 3단계 - 상세 설계
### 클라우드 서비스 사용 여부 - 자체 서비스 사용
- 매월 정렬 집합을 생성해 해당 기간의 순위표를 저장함
- 해당 집합에는 사용자와 점수 정보를 저장
- 이름, 프로필과 같은 정보는 RDB에 저장함
- 순위표를 가져올 때 API 서버는 순위 데이터와 함께 RDB의 프로필 정보도 가져옴
- 장기적으로 비효율 적이지만, 상위 10명의 세부 정보는 캐시를 두어 해결할 수 있음

### 클라우드 서비스 사용 여부 - 클라우드 서비스 사용
- 기존 인프라가 AWS에 있어서 클라우드로 순위표를 구축하는 것이 자연스러운 경우
- API Gateway와 Lambda를 사용함
- API Gateway를 사용하면 RESTful API의 HTTP 엔드포인트를 정의하고 아무 백엔드 서비스에나 연결 가능함
- 람다 함수
    - API : GET /v1/scores
        - 람다 함수 : LeaderboardFetchTop10
    - API : GET /v1/scores/{user_id}
        - 람다 함수 : LeaderboardFetchPlayerRank
    - API : POST /v1/scores
        - 람다 함수 : LeaderboardUpdateScore
    - 람다는 필요할 때만 실행되며 트래픽에 따라 자동적으로 확장됨
- 게임은 API 게이트웨이를 호출하고, 게이트웨이는 적절한 람다 함수를 호출함
    - 해당 람다 함수는 스토리지 계층(레디스나 RDB)의 명령을 호출해 얻은 결과를 API 게이트웨이에 반환하고, API 게이트웨이는 그 결과를 애플리케이션에 전달함
    - 서버 인스턴스 없이 질의를 실행할 수 있음

### 레디스 규모 확장
- 500만 DAU는 한 대로도 지원 가능함
- 5억 DAU가 될 경우 최악에는 65GB(650MB * 100) 정도의 저장 공간이 필요하고, 250_000(2500 * 100) QPS를 처리해야함
    - 이 정도 규모를 감당하기 위해서는 샤딩이 필요함

### 레디스 규모 확장 - 데이터 샤딩 방안 : 고정 파티션
- 순위표에 등장하는 점수 범위에 따라 파티션을 나누는 방안임
- 한 달 동안 얻을 수 있는 점수 범위가 1 ~ 1000일 때 그 데이터를 범위 별로 나누는 것임
    - 특정 사용자의 점수를 입력하거나 갱신 시 해당 사용자가 어느 샤드에 있는지 알아야 함
    - 사용자 점수가 높아져 다른 샤드로 옮겨야할 수 있다는 것도 주의해야 함
    - 상위 10명은 가장 높은 샤드에서 상위 10명을 가져오면 됨
    - 특정 사용자의 순위를 알기 위해서는 해당 사용자가 속한 샤드 내 순위 + 해당 샤드보다 높은 점수의 샤드의 모든 사용자도 알아야 함
    - info keyspace 명령어를 사용하면 특정 샤드에 속한 모든 사용자 수를 O(1)로 알 수 있음

### 레디스 규모 확장 - 데이터 샤딩 방안 : 해시 파티션
- 레디스 클러스터를 이용
    - 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공함
- 점수가 특정 대역에 과도하게 모여있는 경우 유용함
- 안정 해시는 사용하지 않지만, 각각 키가 특정한 해시 슬롯에 속하도록 샤딩 기법을 사용함
    - 총 해시 슬롯 수는 16384개로 고정되어 있음
        - CRC16(key) % 16384 연산으로 어떤 키가 어느 슬롯에 있는지 계산함
    - 모든 키를 재분배하지 않아도 클러스터에 쉽게 노드를 추가하거나 제거 가능
- 점수 갱신 시에는 해당 사용자의 샤드를 찾아 해당 사용자 점수만 변경하면 됨
- 상위 10명의 플레이어 검색은 쉽지 않음.
    - 모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 분산-수집(scatter-gather) 접근법을 사용해야 함
        - 상위 k개의 결과를 반환해야 할 때 k가 클 수록 각 샤드의 많은 데이터를 읽어 정렬해야 하므로 지연 시간 증가
        - 가장 느린 파티션의 데이터를 다 읽어야 계산이 가능함
        - 특정 사용자의 순위를 결정할 간단한 방법이 없음
- 따라서 여기서는 고정 파티션을 사용

### 레디스 노드 크기 조정
- 쓰기 작업이 많은 애플리케이션에는 많은 메모리가 필요함
    - 장애에 대비해 스냅샷을 생성할 때마다 모든 쓰기 연산을 감당할 수 있어야 함
- 쓰기 연산이 많은 애플리케이션을 메모리를 2배 더 할당하는 것이 안전함
- 레디스는 성능 벤치마킹을 위해 redis-benchmark라는 도구를 제공함
    - 여러 클라이언트가 동시에 여러 질의를 실행하는 것을 시물레이션해 초당 얼마나 많은 요청을 처리할 수 있는지 측정함

### 대안 : NoSQL
- 대안이 될 수 있는 NoSQL
    - 쓰기 연산에 최적화되어 있어야 함
    - 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능해야 함
    - DynamoDB, 카산드라, MongoDB 등이 있음
- DynamoDB를 사용함
    - 기본 키 외의 속성으로 효과적으로 질의할 수 있도록 전역 보조 색인을 제공함
    - 부모 테이블의 속성들로 구성되지만, 기본키는 부모 테이블과 다름
    - 사용자 정보와 순위표 등 순위표 화면 표시에 필요한 모든 정보를 담고 있음.
        - 규모 확장성이 좋지 않은 단점이 있음
        - 레코드가 많아지면 상위 점수를 찾기 위해 전체 테이블을 뒤져야 함
        - game_name#{year-month}을 파티션 키로, 점수를 정렬 키로 사용하면 테이블 전체를 읽는 일을 피할 수 있음
    - 부하가 높을 경우 문제가 됨.
        - 안정 해시를 이용해 여러 노드에 데이터를 분산함
        - 여러 파티션에 고르게 분산되어야 하지만, 한 달치 데이터가 동일한 파티션에 저장되므로 핫 파티션이 되어 버림
    - 데이터를 n개의 파티션으로 분할하고 파티션 번호를 파티션 키에 추가하는 것
        - 쓰기 샤딩이라고 부름
        - 읽기와 쓰기 작업 모두를 복잡하게 하므로 잘 따져봐야 함
- 특정한 달의 데이터를 읽을 땐 모든 파티션의 질의 결과를 합쳐야 하므로 구현이 복잡함
- 전역 보조 색인은 game_name#{year-month}#p{partition_number}을 파티션 키로, 점수를 정렬 키로 사용함
    - 같은 파티션 내 데이터는 전부 점수 기준으로 정렬된 n개의 파티션이 만들어 짐
    - 상위 10명은 분산-수집 접근법을 사용함
- 파티션 수를 결정할 땐 신중해야 함.
    - 파티션 수가 많으면 각 파티션의 부하는 줄지만, 최종 순위표를 만들 땐 읽어야 할 파티션이 많아서 복잡해짐
- 사용자 위치를 정확하게 표시하는 것이 아니라, 상위 10~20%와 같이 표기하는 것도 좋을 수 있음
    - 모든 샤드의 점수 분포가 거의 같다고 가정하면 각 샤드의 점수 분포 분석 결과를 캐시하는 크론 작업(cron job)을 만들 수 있다.
    - 그렇게하면 백분위를 빠르게 구할 수 있다

# 4단계 - 마무리
### 더 빠른 조회 및 동점자 순위 판정 방안
- 레디스 해시를 사용하면 문자열 필드와 값 사이 대응관계를 저장해둘 수 있음
    - 순위표에 표시할 사용자 ID와 사용자 객체 사이의 대응관계를 저장.
        - DB에 질의하지 않아도 사용자 정보를 빠르게 확인 가능
    - 두 사용자의 점수가 같은 경우 누가 먼저 점수를 받았는지 순위를 매길 수 있음
        - 사용자 ID와 해당 사용자가 마지막으로 승리한 경기의 타임 스탬프 사이 대응관계를 저장
        - 동점자가 발생하면 타임스탬프 값을 기준으로 가능함

### 시스템 장애 복구
- 사용자가 이길 때마다 RDB에 타임스탬프와 함께 이를 활용하는 스크립트를 만들면 간단히 복구 가능함
- 사용자별로 모든 레코드를 훑으면서, 레코드 당 한 번씩 ZINCRBY를 호출
- 대규모 장애가 발생해도 오프라인 상태에서 순위표를 복구할 수 있음.

### 쓰기 작업아닌가..?