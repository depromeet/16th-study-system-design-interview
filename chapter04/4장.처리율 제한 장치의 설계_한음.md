## 4장 처리율 제한 장치의 설계

### 처리율 제한 장치(rate limiter)
- 처리율 제한 장치는 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치
- 임계치(threshold)를 넘어가는 모든 요청은 처리가 중단된다

### 처리율 제한 장치를 둘 때 장점
- DoS 공격에 의한 자원 고갈 방지
- 서버를 많이 두지 않아도 되고, 우선순위가 더 높은 API에 더 많은 자원을 할당하여, 비용을 절감할 수 있다
- 봇(bot)이나 잘못된 트래픽을 걸러내 과부하를 막음

### 문제 이해 및 설계 범위 확정
- 클라이언트 측 제한 장치인가 / 서버 측 제한 장치인가
- 어떤 기준을 사용해서 API 호출을 제한할 것인가
- 시스템의 규모는 어느 정도인가
- 분산 환경인가
- 처리율 제한장치는 독립된 서비스인가, 애플리케이션 코드인가

### 처리율 제한 장치의 요구사항
- 설정된 처리율을 초과하면 정확하게 제한
- HTTP 응답 시간에 영향을 미치지 않아야 함
- 가능한 한 적은 메모리를 써야 함
- **분산형 처리율 제한** : 하나의 처리율 제한 장치를 여러 서버에서 공유
- 요청이 제한되었다면 클라이언트에게 알려줘야 함
- 처리율 제한 장치에 장애가 생겨도 서비스가 중단되지 않아야 함

### 처리율 제한 장치를 어디에 둘까
- 클라이언트 요청은 쉽게 위변조가 가능하므로 서버 측에 두는 것이 안전
- 서버 API에 두는 대신 미들웨어로 두는 것도 방법
- 마이크로서비스의 경우, 보통 API 게이트웨이에 둔다.
- 여기에서 API 게이트웨이는, 처리율 제한, SSL 종단, 사용자 인증, whitelist 관리 등을 지원한다.
- 다만, 정답은 없다

### 처리율 제한 알고리즘
- **토큰 버킷 알고리즘**
  - 토큰 버킷에 토큰을 넣어두고, 요청이 들어올 때마다 토큰을 꺼내서 처리
  - 토큰이 없으면 요청을 거부
  - 토큰을 넣는 속도와 꺼내는 속도를 조절하여 처리율을 제한
  - 구현이 쉽고, 메모리 사용 측면에서도 효율적
  - 짧은 시간에 집중되는 트래픽도 처리가 가능함
  - 다만, 토큰을 넣는 속도와 꺼내는 속도를 조절하는 것이 중요
- **누출 버킷 알고리즘**
  - 토큰 버킷 알고리즘도 비슷하지만 요청 처리율이 고정되어 있음 (FIFO 큐로 구현)
  - 요청이 도착했을 때 큐가 가득 차 있으면 요청을 거부
  - 큐에 빈자리가 있으면 요청을 처리
  - 지정된 시간마다 요청을 꺼내어 처리함
  - 요청 처리율이 고정되어 있어 트래픽이 짧은 시간에 집중되는 경우에는 최신 요청들이 버려진다
- **고정 윈도 카운터 알고리즘**
  - 특정 시간 동안의 요청 수를 세어서 처리율을 제한
  - 특정 시간 동안의 요청 수가 임계치를 넘어가면 새로운 요청은 새 윈도가 열릴 때까지 버려짐
  - 가장 큰 문제는 위도의 경계 부근에 순간적으로 많은 트래픽이 몰릴 때, 임계치보다 많은 요청이 처리될 수 있다는 것
- **이동 윈도 로깅 알고리즘**
  - 고정 윈도 카운터 알고리즘의 문제를 해결하기 위해 나온 알고리즘
  - 요청의 타임스탬프를 추적하여 레디스 정렬 집합 같은 캐시에 보관함
  - 새 요청이 오면 만료된 타임스탬프는 제거하고 새 타임스탬프를 로그에 추가함
  - 만약 로그에 있는 요청 수가 임계치를 넘어가면 요청을 거부함
  - 허용되는 요청의 개수가 시스템의 처리율 한도를 넘지 않음
  - 다만, 거부된 요청의 타임스탬프도 기록하기 때문에 다량의 메모리를 사용
- **이동 윈도 카운터 알고리즘**
  - 고정 윈도 카운터 + 이동 윈도 로깅 알고리즘을 결합한 것
  - 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에 잘 대응
  - 메모리 효율이 좋음
  - 직전 시간대에 도착한 요청이 균둥하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨함

### 처리율 한도 초과 트래픽의 처리
- 어떤 요청이 한도 제한에 걸리면 HTTP 429 Too Many Requests를 반환
- 나중에 처리하기 위해 큐에 보관할 수도 있다 (ex. 주문 시스템)

### 처리율 제한 장치가 사용하는 HTTP 헤더
- **X-RateLimit-Remaining** : 윈도 내에 남은 처리 가능 요청의 수
- **X-RateLimit-Limit** : 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
- **X-RateLimit-Retry-After** : 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지

### 분산 환경에서 처리율 제한 장치의 구현
- 병행성이 심한 환경에서는 경쟁 조건 이슈가 발생할 수 있다
- 이를 해결하는 해결책은 락(Lock), 하지만 성능을 떨어뜨림
- 다른 해결책으로는 루아 스크립트, 레디스 정렬 집합(sorted set)이 있다
- 수백만 사용자를 지원하기 위해 처리율 제한 장치를 여러 대 두면 동기화가 필요하다
- 고정 세션보다는 레디스를 사용하는 것이 좋다
