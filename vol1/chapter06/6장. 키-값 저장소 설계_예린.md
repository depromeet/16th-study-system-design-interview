# 6장. 키-값 저장소 설계
- 비 관계형 데이터베이스
- 키는 유일해야 하며, 해당 키에 매달린 값은 키를 통해서만 접근할 수 있다.
## 문제 이해 및 설계 범위 확정
### 요구사항
- 키-값 쌍의 크기는 10KB 이하이다.
- 큰 데이터를 저장할 수 있어야 한다.
- 높은 가용성을 제공해야 한다.
- 높은 규모 확장성을 제공해야 한다. 트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.
- 데이터 일관성 수준은 조정이 가능해야 한다.
- 응답 지연시간이 짧아야 한다.
## 단일 서버 키-값 저장소
- 키-값 쌍 전부를 메모리에 해시 테이블로 저장
    - 빠른 속도
    - 모든 데이터를 메모리에 두기에는 한계 존재
- 개선책: 데이터 압축, 자주 쓰이는 데이터 외 나머지는 디스크에 저장
- 그럼에도, 여전히 한 대 서버로는 부족한 순간이 찾아온다.
## 분산 키-값 저장소
- 키-값 쌍을 여러 서버에 분산
### CAP
- Consistency, Availability, Partition Tolerance
- **세 가지 요구사항을 동시에 만족시키는 것은 불가능하다.**
- 일관성: 어떤 노드에 접속해도 언제나 같은 데이터를 볼 수 있어야 한다.
- 가용성: 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있어야 한다.
- 파티션 감내: 두 노드 사이에 통신 장애(파티션)가 발생해도 시스템은 계속 동작해야 한다.
- **어떤 두 가지르 ㄹ 충족하려면 나머지 하나는 반드시 희생되어야 한다.**
- CP 시스템
- AP 시스템
- CA 시스템
    - 통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다. 
    - 즉, 실세계에서 CA는 존재하지 않는다.
#### 실세계의 분산 시스템
- 분산 시스템은 파티션 문제를 피할 수 없다.
- 파티션 문제가 발생하면 일관성과 가용성 사이에 하나를 선택해야 한다.
- 3개 서버 환경에서, 1대에 파티션이 발생
    - 일관성을 선택한다면? 데이터 불일치 문제를 피하기 위해 나머지 서버의 쓰기 연산을 중단 -> 가용성 포기
    - 가용성을 선택한다면? 데이터 불일치 가능성에도 읽기 연산 허용 -> 일관성 포기
#### 시스템 컴포넌트
키-값 저장소 구현에 사용도리 핵심 컴포넌트들 및 기술
- 데이터 파티션
    - 대규모 데이터를 작은 파티션들로 나눠 여러 대 서버에 저장
    - 고려사항
        - 데이터를 여러 서버에 고르게 분산할 수 있는가
        - 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가
    - 안정 해시를 사용한 데이터 파티션의 장점
        - 규모 확장 자동화: 시스템 부하에 따른 서버 자동 추가/삭제
        - 다양성: 각 서버 용량에 맞게 가상 노드 수 조정
- 데이터 다중화
    - 높은 가용성과 안정성을 위해서는 N개 서버에 비동기적으로 다중화 필요
    - 해시 링 위에 시계 방향으로 순회하며 만나는 첫 N개 서버에 데이터 사본 보관
    - 가상 노드를 사용한다면 사본을 보관할 물리 서버를 중복 선택하지 않도록 해야 한다.
    - 안정성을 위해서는 데이터 사본은 다른 센터 서버에 보관
- 일관성
    - 다중화된 데이터는 적절히 동기화 되어야 한다.
    - 정족수 합의 프로토콜
        - N = 사본 개수
        - W = 쓰기 연산에 대한 정족수. 쓰기 연산 성공 == 적어도 W개 서버에서 성공 응답
        - R = 읽기 연산에 대한 정족수. 읽기 연산 성공 == 적어도 R개 서버에서 성공 응답
        - W, R, N 튜닝 == 응답 지연과 데이터 일관성 사이 타협점
        - W+R > N: 강한 일관성
        - W=1, R=N: 빠른 쓰기 연산에 최적화
        - W=N, R=1: 빠른 읽기 연산에 최적화
    - 일관성 모델
        - 데이터 일관성 수준 결정
        - 강한 일관성: 모든 읽기 연산은 가장 최근 갱신 결과를 반환 보장
        - 약한 일관성: 모든 읽기 연산은 가장 최근 갱신 결과를 반환 보장 X
        - 결과적 일관성: 약한 일관성의 한 형태, 갱신 결과가 결국에는 모든 사본에 동기화되는 모델
- 일관성 불일치 해소
    - 데이터 버저닝
        - 데이터 변경마다 새로운 버전을 만드는 것
        - 각 버전의 데이터는 immutable
    - 벡터 시계
        - 서버 1과 서버2가 특정 데이터를 동시에 서로 다른 값으로 수정한다면?
        - 충돌을 발견하고 자동으로 해결해 낼 버저닝 시스템으로 벡터 시계를 사용할 수 있다.
        - 동작 원리
        
            <img width="500" alt="image" src="https://github.com/user-attachments/assets/0ee97e5e-d79e-4a37-a8e8-99e9e2d62857" />

            - Si = 서버 번호, Vi는 버전 카운터
            - [Si, Vi]을 데이터에 첨부: 어떤 버전이 선행인지, 후행인지, 다른 버전과 충돌인지 판별
            - [Si, Vi]가 있으면 Vi를 증가
            - 그렇지 않으면 새 항목 [Si, 1] 생성
      - 벡터 시계를 사용하면 어떤 버전X가 버전 Y의 이전 버전인지 쉽게 판단할 수 있다.
          - 버전 Y에 포함된 모든 구성요소 값이 X에 포함된 모든 구성요소 값보다 같거나 크면 충돌이 없다.
      - 단점
          - 충돌 감지 및 해소 로직이 클라이언트에 들어가야 하므로, 구현 복잡
          - [서버, 버전] 순서쌍 개수가 급증: 임계치를 설정하여, 오래된 순서쌍은 제거하도록 설정
- 장애 처리
    - 장애 감지
        - 모든 노드 사이에 멀티 캐스팅 채널 구축: 비효율적
        - 분산형 장애 감지 솔루션: 가십 프로토콜
            - 동작 원리
              - 각 노드는 멤버십 목록 유지: [멤버 ID, 박동 카운터]
              - 각 노드는 주기적으로 자신의 박동 카운터 증가
              - 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록 전송
              - 박동 카운터 목록을 받은 노드는 멤버십 목록 갱신
              - 어떤 멤버의 박동 카운터 값이 지정된 시간동안 갱신되지 않으면 장애로 간주
    - 일시적 장애 처리
        - 엄격한 정족수 접근법: 읽기와 쓰기 연산 금지
        - 느슨한 정족수 접근법: 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 링에서 선택
        - 단서 후 임시 위탁 기법: 임시로 쓰기 연산ㅇ르 처리한 서버에는 그에 관한 단서를 남겨둔다.
    - 영구 장애 처리
        - 반-엔트로피 프로토콜
            - 사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함
            - 사본 간 일관성 망가진 상태 탐지 및 전송 데이터 양 줄이기 위해 머클 트리(해시 트리) 사용
            - 머클 트리: 각 노드에 그 자식 노드들에 보관된 값의 해시, 또는 자식 노드들의 레이블로부터 개산된 해시 값을 레이블로 붙여두는 트리
            - 머클 트리 비교 시 루트에서부터 아래쪽으로 탐색해나가면서 다른 데이터를 갖는 버킷ㅇ르 찾아 동기화
    - 데이터 센터 장애 처리
        - 여러 데이터 센터에 다중화
#### 시스템 아키텍처 다이어그램
- 중재자: 클라이언트에게 키-값 저장소에 대한 proxy 역할을 하는 노드
- 노드는 안정 해시의 해시 링 위에 분포
- 노드는 자동 추가/삭제 가능하게 시스템은 완전히 분산된다.
- 데이터는 여러 노드에 걸쳐 다중화
- 모든 노드가 같은 책임을 진다: SPOF 없음
#### 쓰기 경로
1. 쓰기 요청이 커밋 로그 파일에 기록
2. 데이터가 메모리 캐시에 기록
3. 메모리 캐시가 가득차거나 임계치에 도달하면 데이터는 디스크에 있는 SSTable(Sorted-String Table)에 기록
   - SSTable: <키,값> 순서쌍을 정렬된 리스트 형태로 관리하는 테이블
#### 읽기 경로
1. 데이터가 메모리 캐시에 있으면 클라이언트에게 반환
2. 데이터가 메모리 캐시에 없으면 블룸 필터를 검사
    a. 블룸 필터: SSTable에 찾는 키가 있는지 효율적으로 알아내는 방법
3. 블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아냄
4. SSTable에서 데이터 조회해서 클라이언트에게 반환
## 마무리

| 목표/문제               | 기술                      |
|---------------------|-------------------------|
| 대규모 데이터 저장          | 안정 해시를 이용한 서버 부하 분산     |
| 읽기 연산에 대한 높은 가용성 보장 | 데이터를 여러 데이터센터에 다중화      |
| 쓰기 연산에 대한 높은 가용성 보장 | 버저닝 및 벡터 시계를 사용한 충돌 해소  |
| 데이터 파티션             | 안정 해시                   |
| 점진적 규모 확장성          | 안정 해시                   |
| 다양성                 | 안정 해시                   |
| 조절 가능한 데이터 일관성      | 정족수 합의                  |
| 일시적 장애 처리           | 느린 정족수 프로토콜, 단서 후 임시 위탁 |
| 영구적 장애 처리           | 머클 트리                   |
| 데이터 센터 장애 대응        | 여러 데이터 센터에 걸친 데이터 다중화   |
