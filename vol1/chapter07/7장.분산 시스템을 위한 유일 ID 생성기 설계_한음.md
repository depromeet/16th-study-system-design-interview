## 7장 분산 시스템을 위한 유일 ID 생성기 설계

### 유일 ID 생성기가 필요한 이유
- auto_increment를 사용하면 되지 않을까?
- 하지만 분산 환경에서는 DB서버 한 대로는 요구를 감당할 수 없다
- 여러 DB 서버를 쓰는 경우에는 지연 시간을 낮추기가 무척 힘들다

### 문제 이해 및 설계 범위 확정
- ID는 어떤 특성을 갖는지
- 새로운 레코드에 붙이는 ID의 특성은 무엇인지 (ex. 항상 1 큰 값을 가지는가)
- 숫자로만 구성되는지
- 시스템 규모는 어느정도 인지

### 개략적 설계안 제시 및 동의 구하기
- 분산 시스템에서 유일성이 보장되는 ID를 만드는 방법은 여러가지
- 다중 마스터 복제
- UUID
- 티켓 서버
- 트위터 스노플레이크 접근법

### 다중 마스터 복제
- 데이터베이스의 auto_increment 기능을 활용하는 것
- 다만, 1만큼이 아닌 k만큼 증가 시킨다
- DB 수를 늘리면 초당 생산 가능 ID도 늘릴 수 있으므로 규모 확장성 문제를 어느정도 해결 가능
- 단점은
    - 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
    - ID의 유일성은 보장되지만 시간 흐름에 맞추어 그 값이 커지도록 보장할 수는 없음
    - 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어려움

### UUID
- UUID는 충돌 가능성이 지극히 낮음
- 서버 간 조율 없이 독립적으로 생성 가능
- 각 웹 서버는 별도의 ID 생성기를 사용해 독립적으로 ID를 만들음
- 단점은
    - UUID는 128비트로 크기가 크다
    - ID를 시간 순으로 정렬할 수 없음
    - 숫자가 아닌 값이 포함될 수 있음

### 티켓 서버
- 핵심은 auto_increment 기능을 갖춘 DB 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것
- 유일성이 보장되고 오직 숫자로만 구성된 ID를 쉽게 만들 수 있음
- 구현하기가 쉽고 중소 규모 애플리케이션에 적합
- 단점은
    - 티켓 서버가 SPOF 가 됨
    - 그렇다고 티켓 서버를 여러대 준비하면 동기화 문제가 발생

### 트위터 스노플레이크 접근법
- divide and conquer 방식
- ID의 구조를 여러 절로 분할하는 것
    - 사인(sign) 비트 : 1비트를 할당, 나중을 위해 유보함. (음수, 양수를 구분하는 등)
    - 타임스탬프 : 41비트
        - 시간의 흐름에 따라 큰 값을 갖게 되므로, 결국 시간 순으로 정렬 가능
        - 41비트는 69년간의 시간을 나타낼 수 있음, 그 이후에는 ID 체계를 마이그레이션 해야함
    - 데이터센터 ID : 5비트, 2^5 = 32개의 데이터센터를 지원
    - 서버 ID : 5비트, 2^5 = 데이터 센터당 32개의 서버를 지원
    - 일련번호: 12비트, 각 서버에서 ID를 생성할 때마다 일련 번호를 1씩 증가

### 상세 설계
- 데이터센터 ID와 서버 ID는 시스템이 시작할 때 결정된다
- 잘못 변경하면 ID 충돌이 발생할 수 있으므로 주의

## 추가 논의할 점
- 시계 동기화: 하나의 서버가 여러 코어에서 실행 될 경우 유효하지 않음, NTP는 이를 해결하는 보편적 수단
- 각 절 길이 최적화: 동시성이 낮고 수명이 길다면 일련 번호 절의 길이를 줄이고, 타임스탬프의 길이를 늘릴 수 있다
- 고가용성: 필수 불가결한 컴포넌트 이므로 높은 가용성을 제공해야한다
