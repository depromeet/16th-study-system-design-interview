# 15장. 구글 드라이브 설계
## 목표
구글 드라이브를 설계하라.
- 파일 저장 및 동기화 서비스
- 문서, 사진, 비디오, 기타 파일을 클라우드에 보관
- 다양한 단말에서 이용 가능
- 타 사용자와 공유 가능
## 1단계. 문제 이해 및 설계 범위 확정
- 기능: 파일 업로드/다운로드, 파일 동기화, 알림
- 단말: 모바일 앱, 웹 앱
- 파일 암호화: 필요
- 파일 크기 제한: 10GB
- 사용자: DAU 1000만 명
### 요구사항
- 파일 추가
- 파일 다운로드
- 여러 단말에 파일 동기화
- 파일 갱신 이력 조회
- 파일 공유
- 파일 편집/삭제 알림
- 안정성, 빠른 동기화 속도, 네트워크 대여폭, 규모 확장성, 높은 가용성
### 개략적 추정치
- 가입 5000만 명, DAU 1000만 명
- 모든 사용자에게 10GB 무료 저장공간 할당
- 매일 각 사용자가 평균 2개 500KB 파일 업로드
- 읽기:쓰기 = 1:1
- 총 저장공간 = 5000만 명 * 10GB = 500PB
- 업로드 API QPS = 1000만 명 * 2회 / 24시간 / 3600초 = 약 240
- 최대 QPS = 240 * 2 = 480
## 2단계. 개략적 설계안 제시 및 동의 구하기
- 파일을 올리고 다운로드 하는 과정을 처리할 웹 서버
- 사용자 데이터, 로그인 정보, 파일 정보 등의 메타데이터를 보관할 DB
- 파일을 저장할 저장소 시스템, 1TB의 공간을 사용할 것
### API
#### 1. 파일 업로드 API
`POST /files/upload?uploadType=resumable`
- data: 업로드할 로컬 파일
- 단순 업로드: 파일 크기 작을 때
- 이어 올리기: 파일 사이즈 크고, 네트워크 문제로 업로드 중단 가능성 높을 때
  - 이어 올리기 URL을 받기 위한 최초 요청 전송
  - 데이터 업로드, 업로드 상태 모니터링
  - 업로드에 장애 발생하면 장애 발생 시점부터 업로드 재시작
#### 2. 파일 다운로드 API
`POST /files/download`
- path: 다운로드 할 파일 경로
#### 3. 파일 갱신 히스토리 API
`GET /files/list_revisions`
- path: 갱신 히스토리 가져올 파일 경로
- limit: 히스토리 최대 길이
### 한 대 서버의 제약 극복
#### 데이터 손실 방지
- 데이터 샤딩
- 객체 저장소 서비스 사용(ex: S3)
- S3 다중화 
  - 같은 지역 내 다중화
  - 여러 데이터 센터에 걸친 다중화
#### 추가 고려사항
- 로드 밸런서: 트래픽 분산
- 웹 서버: 트래픽 폭증에 scale-out 대응
- 메타데이터 DB: 파일 저장 서버에서 분리하여 SPOF 회피, 다중화 및 샤딩 정책으로 가용성 및 규모 확장성 대응
- 파일 저장소: S3를 파일 저장소로 사용하고 가용성/데이터 무손실 보장 위한 데이터센터 다중화

<img alt="image" src="https://github.com/user-attachments/assets/5f84b4d6-0c56-49cb-aecb-173c0526404f">

### 동기화 충돌
- 두 명 이상의 사용자가 같은 파일이나 폴더를 동시에 업데이트
- 해결 방법: 먼저 처리된 변경은 성공, 후에 처리된 변경은 충돌로 처리
  - 오류 발생 시점에 시스템에는 같은 파일의 두 가지 버전 존재
  - 충돌 발생한 사용자의 로컬 사본과 서버 최신 버전을 하나로 합칠지, 대체할지 결정
### 개략적 설계안

<img alt="image" src="https://github.com/user-attachments/assets/60141942-9541-4c74-9091-2b0ad39bfbbe">

## 3단계. 상세 설계
- 블록 저장소 서버
- 메타데이터 DB
- 업로드 절차
- 다운로드 절차
- 알림 서비스
- 파일 저장소 공간 및 정애 처리 흐름
### 블록 저장소 서버
- 역할: 파일 업로드 관련 힘든 일 처리
  - 파일을 블록 단위로 분할
  - 각 블록에 압축 알고리즘 적용
  - 암호화
  - 클라우드 저장소에 전송
- 정기적으로 갱신되는 큰 파일들은 업데이터 발생마다 전체 파일을 전송하면 네트워크 대여폭 과소비
- 최적화
  - 델타 동기화: 수정이 일어난 블록만 동기화
  - 압축: 블록 단위로 압축
### 높은 일관성 요구사항
- 강한 일관성 모델을 기본으로 지원
- 메모리 캐시: 보통 결과적 일관성 모델 지원, 따라서 강한 일관성 달성 위해 다음 사항 보장
  - 캐시에 보관된 사본과 DB에 있는 원본 일치
  - DB에 보관된 원본 변경 발생 시 캐시에 있는 사본 무효화
- 관계형 DB: ACID 지원하는 관계형 DB 채택하여 높은 일관성 요구사항에 대응
### 메타데이터 DB
- 메타 데이터를 왜 분리하여 관리하는가?
- user: 사용자 정보
- device: 단말 정보
- namespace: 사용자의 루트 디렉터리 정보
- file: 파일의 최신 정보
- file_version: 파일 갱신 이력 (읽기 전용: 갱신 이력 훼손 방지)
- block: 파일 블록 정보, 특정 버전 파일은 파일 블록을 올바른 순서로 조합하면 복원 가능
### 업로드 절차
- 파일 메타데이터 추가 요청 & 클라우드 저장소 업로드 요청 병렬 처리
- 파일 메타데이터 추가
  1. 클라이언트가 새 파일 메타데이터 추가 위한 요청 전송
  2. 새 파일의 메타데이터를 DB에 저장하고, 업로드 상태를 대기 중으로 변경
  3. 새 파일 추가를 알림 서비스에 통지
  4. 알림 서비스는 관련 클라이언트에게 파일 업로드 중임을 알림
- 파일을 클라우드 저장소에 업로드
  1. 클라이언트가 파일을 블록 저장소 서버에 업로드
  2. 블록 저장소 서버는 파일을 블록 단위로 분할 & 압축 & 암호화하여 클라우드 저장소에 전송
  3. 업로드 완료 시 클라우드 저장소는 완료 콜백 호출 (API 서버로 전송되는 콜백 호출)
  4. 메타데이터 DB에 기록된 파일 상태를 완료로 변경
  5. 알림 서비스에 파일 업로드 끝남을 통지
  6. 알림 서비스는 관련 클라이언트에게 파일 업로드 완료 알림
### 다운로드 절차
- 파일이 새로 추가되거나 편집되면 자동으로 시작
- 파일 편집/추가 감지 방법
  - 알림 서비스가 관련 클라이언트에게 새 버전 업데이트를 알림
  - 관련 클라이언트가 미접속 상태일 때 데이터를 캐시에 보관하다가, 접속 중으로 바뀌면 그 때 새 버전 끌어감
- 파일 변경 감지한 클라이언트는 API 서버 통해 메타데이터를 새로 가져가서, 블록을 다운 받아 파일을 재구성
- 동작 과정
  1. 알림 서비스가 관련 클라이언트에게 누군가 파일을 변경했음을 알림
  2. 알림 확인한 관련 클라이언트는 새로운 메타데이터 요청
  3. API 서버는 메타데이터 DB에 새 메타데이터 요청 및 반환
  4. 관련 클라이언트는 새 메타데이터 받는 즉시 블록 다운로드 요청 전송
  5. 블록 저장소 서버는 클라우드 저장소에서 블록 다운로드
  6. 관련 클라이언트에게 요청된 블록 반환 및 관련 클라이언트가 파일 재구성
### 알림 서비스
- 파일 일관성 유지 위해 클라이언트는 로컬에서 파일 수정을 감지하는 순간 관련 클라이언트에 알려서 충돌 가능성 줄임
- 이벤트 데이터를 클라이언트들로 보내는 서비스
- 구현 방법
  - 롱 폴링
  - 웹 소켓
- 롱 폴링 사용 근거
  - 양방향 통신 불필요: 서버가 클라이언트에 파일 변경 알림, 반대는 필요 없음
  - 실시간성 불필요
- 롱 폴링 구현 방법
  - 알림 서버와 롱 폴링용 연결을 유지하다가 특정 파일에 대한 변경 감지 시 연결 해제
  - 클라이언트는 반드시 메타데이터 서버와 연결해 파일의 최신 내역을 다운로드
  - 다운로드 작업 완료 or 타임 아웃 발생 시 새 요청 보내 롱 폴링 연결 복원 및 유지
### 저장소 공간 절약
- 파일 갱신 이력 보존, 안정성 보장 위해 여러 버전을 여러 데이터센터에 보관
- 모든 버전을 자주 백업 시 저장용량 빠르게 소진
- 최적화
  - 중복 제거: 중복 파일 블록을 계정 차원에서 제거 (해시값 비교)
  - 지능적 백업 전략 도입
    - 한도 설정: 보관 파일 버전 개수 상한 설정
    - 중요한 버전만 보관
    - 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮김
### 장애 처리
- 로드밸런서 장애: 부 로드밸런서가 활성화되어 트래픽 이어받기, 로드 밸런서끼리 박동 신호 주기적으로 송수신
- 블록 저장소 서버 장애: 다른 서버가 미완료 상태 또는 대기 상태인 작업 이어 수행
- API 서버 장애: 로드밸런서가 트래픽 조정
- 메타데이터 캐시 장애: 다중화
- 메타데이터 DB 장애: 다중화 복구 전략에 따라서
- 알림 서비스 장애: 롱 폴링 유지는 쉽지만, 동시 재시작은 어려움, 상대적으로 복구 느릴 수 있음
- 오프라인 사용자 백업 큐 장애: 다중화
## 4단계. 마무리
### 추가 고려사항
- 블록 저장소 서버를 거치지 않고 파일을 클라우드 저장소에 직접 업로드한다면?
  - 장점: 업로드 속도 빠름
  - 단점:
    - 분할, 압축, 암호화 로직을 클라이언트에 두어야 하므로, 플랫폼 별 구현 필요
    - 클라이언트 해킹 가능성 -> 암호화 로직 위치시키기에 부적절
- 접속 상태 관리 서비스 분리
