# 4장. 분산 메시지 큐
## 목표
데이터 장기 보관, 메시지 반복 소비 등 부가 기능을 갖춘 분산 메시지 큐를 설계하라.
- 메시지 큐는 잘 정의된 인터페이스로 경계가 나뉜 독립적인 블록 간 통신과 조율을 담당한다.
- 이점
  - 결합도 완화: 컴포넌트 사이 강한 결합 제거
  - 규모 확장성 개선: 생산자/소비자 시스템 규모를 트래픽 부하에 맞게 독립적으로 조정
  - 가용성 개선: 시스템 특정 컴포넌트 장애 발생에도 타 컴포넌트는 계속 상호작용
  - 성능 개선: 비동기 통신 제공, 서로 대기할 필요 없음
### 메시지 큐 VS 이벤트 스트리밍 플랫폼
- 둘의 차이는 지원 기능이 수렴하며 점차 희미
- 데이터 장기 보관, 메시지 반복 소비 등의 부가 기능은 통상적으로 이벤트 스트리밍플랫폼에서만 이용 가능
## 1단계. 문제 이해 및 설계 범위 확정
- 메시지 포멧, 크기: 텍스트 형태, 수 킬로바이트 수준
- 반복 소비: 가능, 전통적인 메시지 큐 시스템과 다름
- 전달 순서대로 소비: 생산된 순서 그대로 소비, 전통적인 메시지 큐는 순서 보장 X
- 데이터 지속성 보장, 기간: 2주 보관, 전통적인 메시지 큐는 지속성 보관 보증 X
- 지원해야 하는 생산자/소비자 수: 많을수록 좋음
- 메시지 전달 방식(최대 한 번, 최소 한 번, 정확히 한 번): `최소 한 번` 반드시 지원, 이상적으로는 모두 지원 & 사용자 선택
- 대여폭, end-to-end 지연 시간: 로그 수집 등에 사용 위해 높은 수준의 대여폭, 낮은 전송 지연
### 기능 요구사항
- 생산자는 메시지를 큐로 전송한다.
- 소비자는 메시지를 큐에서 꺼낸다.
- 메시지는 반복적으로 수신할 수 있어야 하고, 단 한번만 수신하도록 설정할 수 있어야 한다.
- 오래된 이력 데이터는 삭제 될 수 있다.
- 메시지 크기는 킬로바이트 수준이다.
- 메시지가 생상된 순서대로 소비자에게 전달한다.
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 중 선택 가능하다.
### 비기능 요구사항
- 높은 대여폭 or 낮은 전송 지연 중 선택 기능
- 규모 확장성
- 지속성 및 내구성
- 데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제
### 전통적 메시지 큐와의 차이점
- 메시지가 소비자에 전달되기 충분한 기간 동안만 메모리에 보관
- 처리 용량 넘어선 메시지는 디스크에 보관하긴 하지만, 이벤트 스트리밍 플랫폼에 비해 아주 낮은 수준
- 메시지 전달 순서 보존 X
## 2단계. 개략적 설계안 제시 및 동의 구하기
### 상호작용 흐름도
1. 생산자는 메시지를 메시지 큐에 발행
2. 소비자는 큐를 구독하고, 구독한 메시지 소비
3. 메시지 큐는 생산자와 소비자 사이 결합을 느슨하게 함
4. 생산자와 소비자의 독립적인 운영 및 규모 확장이 가능함
5. 생산자와 소비자는 모두 클라이언트/서버 관점에서 클라이언트, 메시지 큐는 서버
### 메시지 모델
#### point-to-point 모델
- 소비자가 많아도 각 메시지는 한 소비자만 가져갈 수 있음
- 어떤 소비자가 메시지를 가져갔다는 사실을 큐에 알리면 해당 메시지는 큐에서 삭제
- 데이터 보관 미지원
- 현재 문제에는 적합 X
#### pub-sub 모델
- 토픽: 메시지를 주제별로 정리, 각 토픽은 메시지 큐 서비스 전반에 고유한 이름 보유
- 메시지 송수신은 토픽에 보내고, 받음
### 토픽, 파티션, 브로커
#### 토픽에 보관된 데이터 양이 커져서 서버 한 대로 감당하기 힘들다면?
- 파티션
  - 토픽을 여러 파티션으로 분할해서 모든 파티션에 균등하게 나눠 보냄
  - 토픽에 보낼 메시지의 작은 부분 집합
  - 파티션은 메시지 큐 클러스터 내 서버에 고르게 분산 배치
  - FIFO 큐처럼 동작: 각 파티션 안에는 메시지 순서가 유지
  - 오프셋: 파티션 내 메시지 위치
  - 같은 키를 가진 모든 메시지는 같은 파티션으로 전송
  - 키가 없는 메시지는 무작위 파티션으로 전송
- 브로커
  - 파티션을 유지하는 서버
  - 파티션을 브로커에 분산하는 것이 높은 규모 확장성 달성 비결
  - 토픽 용량 확장하고 싶으면 파티션 개수 확장
- 토픽을 구독한 소비자는 하나 이상의 파티션에서 데이터 꺼냄
- 토픽 구독 소비자가 여럿인 경우, 각 구독자는 해당 토픽을 구성하는 파티션의 일부를 담당 -> 토픽의 소비자 그룹
### 소비자 그룹
- 소비자 그룹 내 소비자는 토픽에서 메시지 소비 위해 서로 협력
- 하나의 소비자 그룹은 여러 토픽을 구독, 오프셋을 별도로 관리
- 같은 그룹 내 쇠자는 메시지를 병렬로 소비 가능
- 문제점
  - 병렬 처리로 인한 파티션 내 메시지 순서대로 소비 보장 어려움
- 해결 방법
  - 특정 파티션 내 메시지는 한 그룹 안에서 오직 한 소비자만 읽을 수 있도록 제약 사항 추가
  - 그룹 내 소비자 수 > 구독하는 토픽의 파티션 수 -> 어떤 소비자는 해당 토픽에서 데이터 읽을 수 없음
  - 일대일 모델처럼 동작하게 됨
- 따라서, 미리 충분한 파티션을 할당하면 파티션 수를 동적으로 늘리는 일 방지
- 처리 용량 늘릴려면 소비자를 더 추가
### 개략적 설계안

<img alt="image" src="https://github.com/user-attachments/assets/4c21d828-c671-4a65-b3f7-10c96b854a3f">

## 3단계. 상세 설계
### 데이터 장기 보관 & 높은 대여폭 제공
- 회전 디스크의 높은 순차 탐색 성능과 현대적 운영체제가 제공하는 적극적 디스크 캐시 전략을 잘이용하는 디스크 기반 자료 구조 활용
- 메시지가 생산자로부터 소비자에게 전달되는 순간까지 아무 수정 없이도 전송이 가능하도록 하는 메시지 자료 구조를 설계/활용
  - 전송 데이터의 양이 막대한 경우에 메시지 복사에 드는 비용 최소화
- 일괄 처리를 우선하는 시스템 설계
  - 소규모 I/O가 많으면 높은 대역폭 지원하기 어려움
  - 생산자는 메시지를 일괄 전송, 메시지 큐는 메시지들을 더 큰 단위로 묶어 전송, 소비자도 메시지 일괄 수신
### 데이터 저장소
- 읽기/쓰기 빈번
- 갱신/삭제 연산 없음
- 순차적인 읽기/쓰기가 대부분
#### 1. 데이터베이스
- 관계형 데이트베이스: 토픽별 테이블 생성, 토픽에 보내는 메시지는 해당 테이블에 레코드로 추가
- NoSQL 데이터베이스: 토픽별 컬렉션 생성, 토픽에 보내는 메시지는 하나의 문서
- 읽기/쓰기 연산이 동시에 대규모로 빈번하게 발생하므로 데이터베이스는 최선의 선택지가 될 수 없음 (오히려 시스템 병목)
#### 2. 쓰기 우선 로그
- WAL: 새로운 항목이 추가되기만 하는 일반 파일
- 사용 예시: MySQL 복구 로그
- 접근 패턴: 읽기/쓰기 모두 순차적
- 새로운 메시지는 파티션 꼬리 부분에 추가 == 오프셋 점진적 증가
  - 로그 파일 줄 번호를 오프셋으로 사용: 파일 크기 무한정 커지지 않도록 세그먼트 단위로 나누기
- 세그먼트
  - 토픽 > 파티션 > 세그먼트
  - 새 메시지는 활성 상태의 세그먼트 파일에만 추가
  - 세그먼트 크기가 일정 한계에 도달하면 새 활성 세그먼트 파일 만들어져 새로운 메시지 수용
  - 종전까지 활성 상태였던 세그먼트 파일은 다른 세그먼트 파일과 마찬가지로 비활성 상태로 변경
  - 비활성 세그먼트는 읽기 요청만 처리
  - 낡은 비활성 세그먼트 파일은 보관 기한이 만료되거나 용량 한계에 도달하면 삭제 가능
#### 디스크 성능 관련 유의사항
- 회전식 디스크 성능 저하: 데이터 접근 패턴이 무작위일 때
### 메시지 자료 구조
- 높은 대역폭 달성의 열쇠
- 자료 구조
  - 생산자, 메시지 큐, 소비자 사이 계약
- 메시지 큐를 거쳐 소비자에게 전달되는 과정에서 불필요한 복사가 일어나지 않도록 하여 높은 대역폭 달성
#### 메시지 키
- 파티션 정할 때 사용
- 없으면 파티션은 무작위 결정
- 파티션 결정: hash(key) % numPartitions
- 키 != 파티션 번호
- 파티션 번호는 메시지 큐 내부적으로 사용되는 개념이므로 클라이언트에게 노출 X
- 해당 키-값은 키-값 저장소에서의 관계와 다름 (키가 고유할 필요 없음)
#### 메시지 값
- 메시지 내용, 페이로드
#### 기타 필드
- 토픽
- 파티션
- 오프셋
- 타임 스템프
- 크기
- CRC
### 일괄 처리
- 생산자, 소비자, 메시지 큐는 메시지를 가급적 일괄 처리
- 시스템 성능에 매우 중요
  - 운영체제로 하여금 여러 메시지를 한 번의 네트워크 요청으로 전송할 수 있도록 하기 때문에 값비싼 네트워크 왕복 비용 제거
  - 브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산 발생 -> 운영체제가 관리하는 디스크 캐시에서 더 큰 규모의 연속 공간 점유 -> 더 높은 디스크 접근 대역폭 달성
- 높은 대역폭 & 낮은 응답 지연 동시 달성의 어려움
  - 낮은 응답 지연 -> 일괄 메시지 양 낮춤 -> 디스크 성능 저하
  - 처리량 높이기 위해서는 토픽 당 파티션 수 늘려야 낮아진 순차 쓰기 연산 대역폭 벌충 가능
### 생산자 측 작업 흐름
