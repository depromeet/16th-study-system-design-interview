# 분산 시스템을 위한 유일 ID 생성기 설계

## 분산 시스템에서 유일 ID 생성기가 필요한 이유
`auto_increment` 사용이 불가능하기 때문이다. 분산 환경에서는 DB가 보통 한 대가 아니라 여러대인데,
1. 각 DB에서 `auto_increment`로 각자 키 관리를 하면 중복 위험성이 높아진다
2. 그렇다고 `auto_increment`를 중앙에서 생성할 수 있도록 관리하면 실시간으로 중앙에서 값을 공유하거나 동기화를 해야하는데, 이는 네트워크 지연 때문에 완벽한 동기화가 불가능하다
3. 위의 네트워크 지연 때문에 ID가 중복될 위험이 있따.
4. 그렇다고 분산 DB환경에서 지연시간을 낮추기도 매우 어렵기 때문에 `auto_increment`는 사실상 사용이 불가능하다고 보면 된다.

---

## 1. 문제 정의 및 요구사항

- 모든 ID는 중복되지 않아야 함.
- ID는 숫자로만 구성되어야 함.
- ID는 64비트 범위 내에 있어야 함.
- 생성 순서(시간 순서)에 따라 나중에 생성된 ID의 값이 더 커야 함.
- 초당 최소 10,000개의 ID를 생성할 수 있어야 함.

---

## 2. ID 생성 접근 방법 및 특징

### 2.1. 다중 마스터 복제 

- **개념**:  
  각 데이터베이스 서버에서 `auto increment`를 사용하되, 서버마다 증가값을 다르게 하여 전체적으로 고유한 값을 생성합니다.  
  예시:
    - 서버 A: 1, 5, 9, …
    - 서버 B: 2, 6, 10, …  
      (서버 수에 따라 증가값 k를 조정)

- **장점**
    - 단순 구현
    - 한 데이터 센터 내에서 확장이 가능함

- **단점**
    - 여러 데이터 센터에 걸쳐 확장하기 어려움
    - 생성된 ID가 시간 순 정렬(생성 순서 반영)을 보장하지 않음 -> 조건 만족x
    - 서버 추가/삭제 시 관리 복잡

---

### 2.2. UUID
128비트의 UUID를 생성하여 고유성을 보장하며, 서버 간의 조율 없이 독립적으로 생성할 수 있음. 

- **장점**
    - 충돌 가능성이 극히 낮음
    - 동기화 이슈 없이 생성 가능

- **단점**
    - 128비트로 용량이 크며, 요구사항인 64비트에 맞지 않음
    - 기본 UUID는 시간 순 정렬이 어렵지만, 정렬 가능한 UUID 변형 가능
    - 형식에 따라 숫자 외의 문자가 포함될 수 있음

---

### 2.3. 티켓 서버 

- **개념**:  
  중앙 집중형 데이터베이스 서버의 `auto_increment` 기능을 활용하여 ID를 생성하는 방식

- **장점**
    - 구현이 간단하며, 유일한 숫자 ID를 쉽게 생성할 수 있음
    - 중소 규모 애플리케이션에 적합

- **단점**
    - 중앙 집중식 구조로 인해 SPOF 위험 존재
    - 그렇다고 고가용성을 위해 여러 서버를 두면 동기화 문제 발생

---

### 2.4. 트위터 스노플레이크

- **개념**:  
  64비트 범위 내에서 여러 Section으로 나누어, 각 비트에 의미를 부여하는 방식

- **ID 구조 (64비트)**
    - **1비트**: 사인 비트 (미래 확장을 위해 예약)
    - **41비트**: 타임스탬프
        - 기원 시각 이후 경과한 밀리초 단위를 저장 
    - **5비트**: 데이터 센터 ID
        - 최대 32개의 데이터 센터 지원
    - **5비트**: 서버 ID
        - 각 데이터 센터 내 최대 32대 서버 지원
    - **12비트**: 일련번호
        - 같은 밀리초 내 최대 4096개의 ID 생성 가능

- **장점**
    - 64비트 요구사항 충족
    - 생성 시간이 포함되어 있어 정렬 가능 (시간 순서 보장)
    - 분산 환경에서 데이터 센터 및 서버별로 독립적 ID 생성 가능

- **단점**
    - 타임스탬프 영역이 41비트이므로, 기원 시각 이후 약 69년 후 재설계 또는 기원 조정 필요
    - 동일 밀리초 내 4096개 이상의 요청이 발생하면 대기 필요
    - 서버 간 시계 동기화(NTP 등)를 반드시 보장해야 함

---

## 3. 트위터 스노플레이크 상세 설계

### 3.1. 각 구성 요소의 역할

1. **사인 비트 (1비트)**
    - 미래 확장을 위해 예약됨.
2. **타임스탬프 (41비트)**
    - 특정 기원 시각(예: 시작 날짜) 이후 경과한 밀리초 값을 저장.
    - 시간 순 정렬 보장.
3. **데이터 센터 ID (5비트)**
    - 분산된 환경에서 각 데이터 센터를 구분하기 위한 값.
4. **서버 ID (5비트)**
    - 각 데이터 센터 내에서 어떤 서버가 ID를 생성했는지 식별.
5. **일련번호 (12비트)**
    - 같은 밀리초 내에서 다수의 요청에 대해 고유성을 부여.
    - 1밀리초 당 최대 4096개의 ID 생성 가능.

### 3.2. 추가 고려 사항

- **시계 동기화**:  
  분산 환경에서는 각 서버의 로컬 시계 차이가 있을 수 있으므로, [NTP(Network Time Protocol)](https://www.ntp.org/) 등으로 시계를 동기화해야 합니다.

- **일련번호 오버플로**:  
  동일 밀리초에 4096개 이상의 ID 요청이 들어올 경우, 해당 밀리초가 지나야 일련번호가 초기화되므로, 대기 또는 에러 처리가 필요합니다.

- **비트 할당 최적화**:  
  시스템의 특성(동시성, 수명 등)에 따라 타임스탬프와 일련번호에 할당된 비트 수를 조정할 수 있습니다.

- **고가용성**:  
  ID 생성기는 시스템 전반에 영향을 미치는 핵심 컴포넌트이므로, 장애 발생 시 전체 시스템에 영향을 주지 않도록 장애 조치 및 중복 생성 서버 구성 등 고가용성 설계가 필요합니다.
