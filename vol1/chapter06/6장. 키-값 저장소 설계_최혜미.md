# 6장: **키-값 저장소 설계**

## 1. 키-값 저장소란?
키-값 저장소는 NoSQL의 한 종류로, 고유 식별자(key)를 사용하여 데이터를 저장하는 방식이다.  
키-값 쌍으로 데이터를 저장하며, 대표적인 사례로 Amazon DynamoDB, Memcached, Redis가 있다.

---

## 2. 키-값 저장소의 설계 요구사항
1. 큰 데이터 저장 가능
2. 높은 가용성 (서버 장애 시에도 빠른 응답)
3. 높은 규모 확장성 제공 가능 (트래픽 양에 따라 자동 서버 증설 및 삭제)
4. 데이터 일관성 조절 가능
5. 최소한의 응답 지연 시간

---

## 3. 단일 키-값 저장소 설계
단일 서버에서 키-값 저장소를 운영하는 가장 직관적인 방법은 **메모리에 해시 테이블을 사용하여 모든 키-값을 저장**하는 것이다.
- 장점 : 빠른 데이터 접근 속도, 단순 설계
- 단점 : 모든 데이터를 메모리에 저장하는 것은 불가능

단점은 데이터 압축, 자주 쓰는 데이터만 메모리에 저장하고 나머지는 디스크 이동으로 어느 정도 해결은 가능하나 한 대의 서버로 부족할 때가 곧 찯아온다.
그럴 분산 키-값 저장소를 사용을 고려해보아야 한다.


---

## 4. 분산 키-값 저장소
단일 서버 방식의 한계를 극복하기 위해 **데이터를 여러 서버에 분산하여 저장**하는 방식이 필요하다.  
이를 효과적으로 설계하기 위해서는 **CAP 이론**을 이해해야 한다.

### CAP 정리
분산 시스템은 **일관성, 가용성, 파티션 감내** 중 **두 가지만 선택할 수 있다**.(세 가지를 모두 만족하기는 불가능)
- 데이터 일관성 : 어떤 노드에 접속하더라도 동일 데이터를 보아야함
- 가용성 : 일부 노드에 장애가 발생하더라도 항상 응답받아야함
- 파티션 감내 : 두 노드 사이에 통신 장애가 발생하더라도(파티션) 시스템은 계속 동작 되어야한다

### CAP 이론 적용 예시
1. **은행 시스템**: CP 시스템 선택 (데이터 일관성이 최우선)
2. **SNS 서비스**: AP 시스템 선택 (일시적 일관성 저하를 감수하고 가용성 확보)
> CA 시스템은 존재 불가능 : 네트워크 장애는 피할 수 없으므로 분산 시스템에서는 반드시 파티션 문제를 감내할 수 있도록 설계되어야 하기 때문

---

## 5. 키-값 저장소의 핵심 컴포넌트

### **데이터 파티션**
- 대규모 데이터를 여러 서버에 분산 저장
- 안정 해시를 활용하여 데이터 이동 최소화(규모 확장 자동화와 가상 노드 수를 조정할 수 있는 다양성을 장점으로 가짐)
- 서버 추가/삭제 시 최소한의 데이터만 이동

### **데이터 다중화**
- 높은 가용성을 위해 데이터를 N개의 서버에 복제
- N = 3일 경우, 데이터는 3개 서버에 저장됨(노드 선택 시 같은 물리 서버 중복 선택하지 않도록 주의 필요)
- 특정 서버 장애 시에도 다른 서버에서 데이터 제공 가능

### **데이터 일관성**
- 정족수 합의 사용
- N: 사본 개수, W: 쓰기 정족수, R: 읽기 정족수

| 구성         | 설명                |
|------------|-------------------|
| `R=1, W=N` | 빠른 읽기 (읽기 성능 최적화) |
| `W=1, R=N` | 빠른 쓰기 (쓰기 성능 최적화) |
| `W+R > N`  | 강한 일관성 보장         |
| `W+R <= N` | 강한 일관성 보장 x       |

### **일관성 모델**
- **강한 일관성**: 모든 읽기 연산이 최신 데이터를 반환
- **약한 일관성**: 최신 데이터를 반환하지 않을 수도 있음
- **결과적 일관성**: 시간이 지나면 결국 데이터가 동기화됨

> 강한 일관성은 **가용성 저하**를 초래할 수 있기 때문에 **고가용성 시스템에는 적합하지 않음**.

### 데이터 버저닝 & 벡터 시계
- 데이터가 여러 서버에 복제될 때, **동시에 갱신된 값이 충돌**할 가능성이 있음
- 이를 해결하기 위해 각 데이터에 버전을 부여(벡터 시계를 사용하여 충돌 해결)

---

## 6. 장애 처리

### **장애 감지**
- **가십 프로토콜**을 활용하여 장애 서버 탐지 (노드 간 주기적으로 박동 카운터를 공유하여 장애 감지)

### **일시적 장애 처리**
- 장애 발생 시 느슨한 정족수 접근법을 사용하여 다른 노드가 요청을 대신 처리
- 장애가 복구되면 변경 사항을 임시위탁 방식으로 동기화
- 임시위탁 : 임시로 쓰기 연산을 처리한 서버가 그에 관한 힌트를 남기고 서버가 복구되었을 때 일괄 반영(데이터 일관성 보존)

### **영구 장애 처리**
- 장애 발생 시 **반-엔트로피 프로토콜**을 사용하여 데이터 복구
- 머클 트리를 사용하여 데이터 동기화 비용 최소화

### **데이터 센터 장애 처리**
- 여러 데이터 센터에 다중화하여 장애 발생 시에도 지속적인 서비스 제공
- 데이터 센터 간 고속 네트워크 연결을 통해 데이터 복제 수행

---

## 7. 키-값 저장소 아키텍처

### **시스템 아키텍처 개요**
- 클라이언트는 **GET(key), PUT(key, value)** API를 사용하여 통신
- 중재자는 클라이언트에게 키-값 저장소에 대한 프록시 역할을 하는 노드
- 노드를 자동으로 추가/삭제 할 수 있도록 시스템은 완전히 분산된다
- 데이터는 여러 노드에 다중화
- 노드는 안정 해시를 기반으로 해시 링에 배치됨
- 모든 노드가 같은 책임을 가짐 (SPOF 없음)

### **데이터 읽기**
1. **캐시(memory)에서 데이터 조회**
2. **디스크(SSTable)에서 데이터 조회 (캐시에 없는 경우)**
3. **블룸 필터 활용하여 필요한 SSTable만 접근**

### **데이터 쓰기**
1. **커밋 로그 기록**
2. **메모리 캐시 저장**
3. **메모리 캐시가 가득 차면 디스크(SSTable)로 이동**

---


| 목표/문제 | 해결 기술 |
|------------|------------|
| 대규모 데이터 저장 | **안정 해시** |
| 읽기 연산 가용성 | **여러 데이터 센터에 다중화** |
| 쓰기 연산 가용성 | **버저닝 & 벡터 시계** |
| 데이터 파티션 | **안정 해시** |
| 확장성 | **안정 해시 기반 자동 확장** |
| 데이터 일관성 조정 | **정족수 합의** |
| 일시적 장애 처리 | **Hinted Handoff** |
| 영구 장애 처리 | **머클 트리 기반 데이터 복구** |


