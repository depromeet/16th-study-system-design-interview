# 12장 - 채팅 시스템 설계
## 1단계 - 문제 이해 및 설계 범위 확정
- 요구 사항 파악
  - Q) 어떤 앱을 설계해야 하나요? 1:1 채팅, 그룹 채팅
    - A) 둘 다 지원할 수 있어야 함
  - Q) 모바일 앱인가요 아니면 웹인가요?
    - A) 둘 다입니다.
  - Q) 처리해야 하는 트래픽 규모는 어느 정도인가요?
    - A) 일별 능동 사용자 수(DAU) 기준으로 5천만명을 처리할 수 있어야 함
  - Q) 그룹 채팅의 경우 인원 제한이 있나요?
    - A) 최대 100명까지 참여 가능
  - Q) 중요 기능으로 어떤 것이 있는가? 가령, 첨부파일도 지원해야 하나요?
    - A) 1:1, 그룹, 사용자 접속상태 표시를 지원. 텍스트 메시지만 주고받을 수 있음.
  - Q) 메시지 길이에 제한이 있나요?
    - A) 네. 100,000자 이하여야 함
  - Q) 종단 감 암호화를 지원해야 하나요?
    - A) 현재는 필요 없지만, 시간이 허락하면 논의해볼 수 있다.
  - Q) 채팅 이력은 얼마나 보관하는가?
    - A) 영원히

- 요구 사항
  - 응답지연이 낮은 1:1 채팅
  - 최대 100명 참여 가능한 그룹 채팅
  - 사용자 접속상태 표시
  - 다양한 단말 지원.
    - 하나의 계정으로 여러 단말 동시 접속
  - 푸시 알림

## 2단계 - 개략적 설계안 제시 및 동의 구하기
- 채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애플리케이션으로, 클라이언트가 서로 직접 통신하지 않는다.
  - 각 클라이언트는 위에서 나열한 모든 기능을 지원하는 채팅 서비스와 통신함
- 채팅 서비스의 기본 기능
  - 클라이언트들로부터 메시지 수신
  - 메시지 수신자 결정 및 전달
  - 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관
- 통신 프로토콜 결정도 중요한 사항 중 하나임
  - HTTP 프로토콜로 연결할 경우
    - keep-alive 헤더를 사용하면 효율적
      - 클라-서버 간의 연결을 끊지 않고 계속 유지함
        - 핸드쉐이크 횟수를 줄임
  - 폴링
    - 주기적으로 새 메시지가 있는지 통신하는 방법
    - response가 없을 경우 서버 자원을 불필요하게 낭비한다는 단점이 존재
  - 긴 폴링
    - 긴 홀링은 새 미시지가 반환되거나 타임아웃될 때까지 연결을 유지
    - 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작
    - 약점
      - 메시지를 보내는 클라와 수신하는 클라가 같은 채팅 서버에 접속하지 않을 수 있음.
      - 로드밸런싱 사용 시 메시지를 받는 서버는 해당 메시지를 수신할 클라와 롱 폴링 연결을 갖고 있지 않은 서버일 수 있다
      - 서버는 클라가 연결을 해제했는지 아닌지 알 방법이 없음
      - 여전히 비효율적임. 메시지를 많이 받지 않는 클라도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속함
  - 웹소켓
    - 서버가 클라에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
    - 연결
      - 클라가 연결을 시작함.
      - 한 번 맺어진 연결은 항구적이며 양방향임
      - 처음에는 HTTP 연결이지만, 특정 핸드쉐이크 절차를 거쳐 웹소켓 연결로 업그레이드됨
      - 항구적인 연결이 만들어지고 난 후에는 서버는 클라에게 비동기적으로 메시지를 전송할 수 있음
      - 일반적으로 방화벽이 있는 환경에도 잘 동작함.
        - HTTP 혹은 HTTPS 프로토콜이 사용하는 80이나 443과 같은 기본 포트번호를 그대로 사용하기 때문
    - 웹소켓은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야 한다

### 개략적 설계안
- 클라와 서버 사이의 주 통신 프로토콜로 웹소켓 사용
- 크게 세 부분으로 나눔
  - 무상태 서비스
  - 상태유지 서비스
  - 제3자 서비스 연동

### 개략적 설계안 - 무상태 서비스
- 로그인, 회원가입, 사용자 프로필 표시 등을 처리하는 전통적인 요청/응답 서비스
- 대부분의 웹사이트와 앱이 보편적으로 제공하는 기능
- 로드밸런서 뒤에 위치함.
- 로드밸런서가 하는 일은 요청을 그 경로에 맞는 서비스로 정확하게 전달하는 것.
- 서비스 탐색(service discovery)
  - 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할

### 개략적 설계안 - 상태유지 서비스
- 유일하게 채팅 서비스만 해당
- 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야함.
- 보통 서버가 살아있는 한 다른 서버로 연결을 변경하지 않음.
- 서비스 탐색(service discovery) 서비스는 채팅 서비스와 긴밀하게 협력해 특정 서버에 부하가 몰리지 않도록 함

### 개략적 설계안 - 제3자 서비스 연동
- 가장 중요한 제3자 서비스는 푸시 알림임
- 새 메시지를 받았다면 앱이 실행 중이지 않아도 알림을 받아야 함.

### 규모 확장성
- 서버 한 대로 얼마나 많은 접속을 동시에 허용할 수 있는지가 관건.
  - 동시 접속자가 1M이라고 가정
  - 접속 당 10K의 서버 메모리가 필요하다고 가정
  - 10GB 메모리로 모든 연결을 처리할 수 있음.
- 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할을 담당
- 접속상태 서버(presence server)는 사용자 접속 여부를 관리
- API 서버는 로그인, 회원가입 등 나머지 전부를 처리
- 알림 서버는 푸시 알림을 보냄
- key-value 저장소에는 채팅 이력을 보관
  - 시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게 됨

### 저장소
- DB 선택에서 중요하게 따져야 하는 것은 데이터의 유형과 읽기/쓰기 연산의 패턴이다.
- 채팅 시스템에서 주로 다루는 데이터
  - 안정성을 보장하는 관계형 DB에 보관
    - 사용자 프로파일, 설정, 친구 목록 같은 일반적인 데이터
    - 다중화와 샤딩을 통해 데이터의 가용성과 규모확장성을 보증할 수 있음
  - key-value DB 선택
    - 채팅 이력
      - 데이터 양이 엄청남.
      - 빈번하게 사용되는 것은 최근에 주고받은 메시지임.
        - 대부분 오래된 메시지는 들여다보지 않음
      - 검색 기능, 특정 사용자 언급, 특정 메시지로 점프 등을 통해 무작위적인 데이터 접근을 하게되는 일도 존재
        - 이런 기능을 지원해야함.
      - 1:1 채팅은 읽기:쓰기 비율이 1:1 정도다
    - key-value는 수평 확장이 쉬움
    - 데이터 접근 지연시간이 낮음.
    - RDB는 데이터 가운데 롱 테일(long tail)에 해당하는 부분을 잘 처리하지 못하는 경향이 있음.
    - RDB는 인덱스가 커지면 무작위 접근(random access)을 처리하는 비용이 늘어남.

### 데이터 모델 - 1:1 채팅을 위한 메시지 테이블
- message_id
  - pk
  - 메시지 순서를 쉽게 저장할 수 있는 역할도 담당
- message_from
- message_to
- content
- created_at
  - 메시지 순서를 정할 수는 없음.
  - 서로 다른 두 메시지가 동시에 만들어질 수 있기 때문

### 데이터 모델 - 그룹 채팅을 위한 메시지 테이블
- channel_id
  - 채팅 그룹과 같은 뜻
  - 파티션 키로도 사용됨.
    - 그룹 채팅에 적용될 모든 질의는 특정 채널을 대상으로 하기 때문.
- message_id
- message_to
- content
- created_at
- channel_id와 message_id의 복합키를 기본 키로 사용


### 데이터 모델 - 메시지 ID
- message_id는 메시지 순서도 표현할 수 있어야 함.
  - message_id는 고유해야함.
  - ID 값은 정렬이 가능해야 하고 시간 순서와 일치해야함.
    - 새로운 ID는 이전 ID보다 큰 값이어야 함
- NoSQL에는 auto_increment 기능이 보통 없음.
- 스노플레이크 사용
- 지역적 순서 번호 생성기 사용
  - ID 유일성은 같은 그룹 안에서만 보증하면 충분함.
    - 메시지 사이의 순서는 같은 채널 안에서만 유지되면 됨.
  - 전역 ID 생성기에 비해 구현이 쉬움

### Q) RDB에서 인덱스가 커지면 random access 비용이 늘어나는 이유?

## 3단계 - 상세 설계
### 서비스 탐색
- 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것.
  - 기준은 클라이언트의 위치(geographical location), 서버의 용량(capacity) 등이 있음
- 아파치 주키퍼 같은 오픈 소스 솔루션이 있음
  - 사용 가능한 모든 채팅 서버를 여기 등록시키고 클라가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라줌.
  - 동작
    - 사용자 A가 시스템에 로그인을 시도함.
    - 로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보냄
    - API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작해 최적의 채팅 서버를 찾음
    - A는 채팅 서버와 추천된 웹 소켓 연결을 맺게 됨.

### 메시지 흐름 - 1:1 채팅 메시지 처리 흐름
- 사용자 A가 B에게 보낸 메시지가 처리되는 경로
  - A가 채팅 서버 1로 메시지 전송
  - 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정
  - 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
  - 메시지가 key-value 저장소에 보관
  - a) 사용자 **B가 접속 중인 경우** 사용자 B가 접속 중인 채팅 서버로 전송
  - b) 사용자 **B가 접속 중이 아닌 경우** 푸시 알림 메시지를 푸시 알림 서버로 보냄
  - 서버 2는 메시지를 B에게 전송. B와 서버 2 사이에는 웹소켓 연결이 있는 상태이므로 그것을 이용

### 메시지 흐름 - 여러 단말 사이의 메시지 동기화
- A가 사용하는 서로 다른 단말은 서버와 별도 웹 소켓 연결이 되어 있음.
- 각 단말은 cur_max_message_id라는 변수를 유지함
  - 해당 단말에서 관측된 가장 최신 메시지의 ID를 추적하는 용도
  - 아래 두 조건을 만족하면 새 메시지로 간주함
    - 수신자 ID가 현재 로그인한 사용자 ID와 같음
    - key-value 저장소에 보관된 메시지로서, 그 ID가 cur_max_message_id보다 크다
- cur_max_message_id는 단말마다 별도로 유지 관리하면 되는 값임.
  - key-value 저장소에서 새 메시지를 가져오는 동기화 작업도 쉽게 구현 가능

### 메시지 흐름 - 여러 단말 사이의 메시지 동기화 (A, B, C가 채팅을 하고 있는 상황)
- A가 보낸 메시지는 B와 C의 메시지 동기화 큐에 복사됨
- 이 큐를 사용자 각각에 할당된 메시지 수신함 같은 것으로 생각해도 무방함.
- 해당 설계안은 소규모 그룹 채팅에 적합함
  - 새로운 메시지가 왔는지 확인하려면 자기 큐만 보면되므로 메시지 동기화 플로우가 단순하다
  - 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 문제가 되지 않음.
  - 많은 사용자를 지원해야할 경우 똑같은 메시지를 모든 사용자의 큐에 복사하는 게 바람직하지 않음
- 수신자는 여러 사용자로부터 오는 메시지를 수신할 수 있어야 함

### 접속 상태 표시
- 사용자의 접속 상태를 표시하는 것은 상당수 채팅 애플리케이션의 핵심적인 기능임
- 접속상태 서버(presense server)를 통해 사용자의 상태를 관리함.
  - 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부임

### 접속 상태 표시 - 사용자 로그인
- 클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어진 후에 접속상태 서버는 A의 상태와 last_active_at 타임스탬프 값을 key-value 저장소에 보관
- 이 절차가 끝나면 사용자는 접속 중인 것으로 표시 됨

### 접속 상태 표시 - 로그아웃
- key-value 저장소에 보관된 사용자 상태가 online에서 offline으로 변경됨

### 접속 상태 표시 - 접속 장애
- 사용자의 인터넷 연결이 끊어지면 클라와 서버 사이에 맺어진 웹소켓 같은 지속성 연결도 끊어짐.
- 간단한 장애 대응 방법은 사용자를 오프라인으로 표시하고 연결이 복구되면 온라인으로 변경하는 것.
  - 짧은 시간 인터넷 연결이 끊어졌다 복구되는 일은 흔함.
- 박동 검사를 통해 이 문제를 해결.
  - 온라인 상태의 클라이언트는 주기적으로 박동 이벤트(heartbeat event)를 접속상태 서버로 보내도록 함.
  - 마지막 입네트를 받은 지 x초 이내에 다른 박동 이벤트 메시지를 받으면 접속상태를 계속 온라인으로 유지.
  - 그렇지 않을 경우에만 오프라인으로 변경

### 접속 상태 표시 - 상태 정보의 전송
- 상태 정보 서버는 발행-구독 모델(publish-subscribe model)을 사용함.
  - 각각의 친구관계마다 채널을 하나씩 두는 것
- A의 접속 상태가 변경되면 그 사실을 세 개의 채널에 씀
  - A-B
  - A-C
  - A-D
  - 그룹 크기가 작을 때에는 효과적으로 사용 가능
  - 그룹 크기가 커지면 접속상태 변화를 알리는 비용과 시간이 많이 들게 됨.
  - 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽거나 수동으로 하도록 유도할 수 있다.

## 4단계 - 마무리
- 추가 논의 내용
  - 채팅 앱을 확장해 사진이나 비디오 등의 미디어를 지원하도록 하는 방법
    - 미디어는 텍스트에 비해 크기가 큼
    - 압축 방식, 클라우드 저장소, 썸네일 생성 등
  - 종단 간 암호화
    - 메시지 발신인과 수신자 외에는 아무도 메시지 내용을 볼 수 없다
  - 캐시
    - 클라에서 이미 읽은 메시지를 캐시하면 서버와 주고받는 데이터 양을 줄일 수 있음
  - 로딩 속도 개선
    - 슬랙은 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축해 앱 로딩 속도를 개선
  - 오류 처리
    - 채팅 서버 오류
      - 서버가 죽으면 서비스 탐색 기능(주키퍼 같은)이 동작해 클라에게 새로운 서버를 배정하고 다시 접속할 수 있게 해야 함
    - 메시지 재시도
      - retry 로직이나 큐 등을 통해 메시지를 안정적으로 전송할 수 있게함