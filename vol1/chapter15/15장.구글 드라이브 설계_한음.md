## 15장 구글 드라이브 설계

### 문제 이해 및 설계 범위 확정
- 다음 기능에 집중해보자
  - 파일 추가
  - 파일 다운로드
  - 여러 단말에 파일 동기화
  - 파일 갱신 이력 조회
  - 파일 공유
  - 파일 편집 삭제에 대한 알림 표시

### 개략적 설계안 제시 및 동의 구하기
- 모든 것을 담은 한 대 서버에서 출발해 점진적으로 발전시켜 나가보자
  - 파일을 올리고 다운로드할 웹서버
  - 사용자 데이터, 로그인 정보, 파일 정보 등을 보관할 데이터베이스
  - 파일 저장소 시스템
- 파일 업로드 API, 파일 다운로드 API, 파일 갱신 히스토리 API가 필요함

### 한 대 서버의 제약 극복
- 만약 10MB의 여유 공간 밖에 남지 않았다면
- 급한 불을 끄기 위해 데이터를 샤딩하여 여러 서버에 나누어 저장하자
- 서버에 장애가 생겨 데이터를 잃을까봐 걱정할 수 있다
- S3를 도입하여 데이터를 다중화 해보자
- 추가적인 고민
  - 로드밸런서 : 네트워크 트래픽을 분산하기 위해 도입한다
  - 웹 서버 : 로드밸런서를 추가하면 더 많은 웹 서버를 손쉽게 추가할 수 있다
  - 메타데이터 데이터베이스 : 데이터베이스를 파일 저장 서버에서 분리하여 SPOF를 회피한다
  - 파일 저장소 : S3를 파일 저장소로 사용하고 두 개 이상의 지역에 다중화한다

### 동기화 충돌
- 두 명 이상의 사용자가 같은 파일이나 폴더를 동시에 업데이트 하려고 하는 경우 어떻게 충돌을 해소하는가
- 먼저 처리되는 변경은 성공한 것으로 보고, 나중에 처리되는 변경은 충돌이 발생한 것으로 표시할 수 있음

### 상세 설계
- 블록 저장소 서버
- 높은 일관성 요구사항
  - 메모리 캐시는 결과적 일관성이다
  - 관계형 데이터베이스는 ACID를 보장하므로 강한 일관성을 보장하기 쉽다
  - NoSQL에서는 동기화 로직 안에 프로그램해 넣어야 한다
- 메타데이터 데이터베이스
- 업로드 절차
  - 메타데이터 전송, 저장소로 업로드 하는 과정이 병렬적으로 이루어져야 한다
- 다운로드 절차
  - 다른 클라이언트가 파일을 편집하거나 추가했다는 사실을 감지해 자동으로 다운로드해야함
- 알림 서비스
- 저장소 공간 절약
- 장애 처리

### 블록 저장소 서버
- 큰 파일들은 갱신될 때 네트워크 대역폭을 많이 잡아 먹는다
  - 델타 동기화 : 수정이 일어난 블록만 동기화
  - 압축 : 블록 단위로 압축해두면 데이터 크기를 줄일 수 있다
- 블록 저장소 서버는 클라이언트가 보낸 파일을 블록 단위로 나누고, 압축 하고, 암호화 해야함
- 전체 파일을 저장소 시스템으로 보내는 대신 수정된 블록만 전송해야한다

### 알림 서비스
- 파일이 수정되었음을 알리는 순간 다른 클라이언트에게 그 사실을 알려야 한다
  - 롱 폴링 : 드롭박스가 채택
  - 웹 소켓 : 서버 사이에 지속적인 통신 채널을 제공
- 롱폴링을 사용할건데 그 이유는
  - 채팅 서비스와 달리 양방향 통신이 필요하지 않다
  - 드라이브의 경우 알림을 실시간으로 보낼 일이 자주 발생하지 않으며, 단시간에 많은 양의 데이터를 보내지 않는다

### 저장소 공간 절약
- 중복 제거 : 중복된 파일 블록을 해시 값을 비교하여 제거한다
- 지능적 백업 전략 
  - 보관해야하는 파일 개수에 상한을 두고, 오래된 버전은 버림
  - 중요한 버전만 보관
- 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다 (아마존 S3 글래시어)