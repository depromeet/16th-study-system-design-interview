# 검색어 자동완성 시스템 설계 요약

이 문서는 구글 검색, 아마존 웹사이트 검색창 등에서 볼 수 있는 **검색어 자동완성 시스템**을 설계하기 위한 주요 개념과 고려사항을 정리한 자료입니다.

---

## 1. 문제 이해 및 설계 범위 확정

- **기본 요구사항**
    - 사용자가 단어를 입력하면 첫 부분에 해당하는 검색어 자동완성 후보를 제시
    - **자동완성 후보 개수**: 5개
    - 후보 선택 기준: **검색어 사용 빈도(인기 순위)**
    - 맞춤법 검사 기능은 **제공하지 않음**
    - 입력은 **영어 소문자** (다국어 지원 가능성은 고려)

- **비기능적 요구사항**
    - **빠른 응답속도**: 100밀리초 이내
    - **연관성**: 입력한 단어와 밀접한 연관성 유지
    - **정렬**: 인기 순위(빈도 기반) 정렬
    - **규모 확장성**: 높은 트래픽 처리 (DAU 1천만 명, QPS 약 24,000~48,000)
    - **고가용성**: 일부 장애 발생 시에도 서비스 지속

- **트래픽 및 데이터 추정**
    - 사용자 1천만 명, 하루 평균 10회 검색
    - 한 검색어 질의당 평균 20바이트 데이터 입력
    - 매 검색마다 여러 요청(예: `d`, `di`, `din`, …) 전송
    - 신규 검색어는 전체의 약 20% → 매일 약 0.4GB의 신규 데이터 추가

---

## 2. 개략적 설계안

- **두 가지 주요 컴포넌트**
    - **데이터 수집 서비스**
        - 사용자가 입력한 질의를 실시간으로 수집하여 **검색어 빈도 테이블**에 저장
    - **질의(자동완성) 서비스**
        - 주어진 prefix에 대해 인기 검색어 5개를 반환
        - SQL 예시:
          ```sql
          SELECT * FROM frequency_table
          WHERE query LIKE 'prefix%'
          ORDER BY frequency DESC
          LIMIT 5;
          ```
        - 단, 데이터가 많아지면 단순 SQL 쿼리로는 **DB 병목 현상** 우려

---

## 3. 상세 설계

### 3.1 트라이(Trie) 자료구조 활용

- **트라이 개요**
    - 트리 형태의 자료구조로, 각 노드가 하나의 **문자**를 저장
    - 루트는 빈 문자열, 각 노드는 하나의 단어 또는 접두어를 표현
    - 예시: `tree`, `try`, `true`, `toy`, `wish`, `win`

- **검색 연산**
    - **접두어 노드 탐색**: 시간복잡도 O(p) (p: 접두어 길이)
    - **하위 트리 탐색**: O(c) (c: 해당 노드의 자식 개수)
    - **정렬 후 k개 추출**: O(c log c)
    - → 전체 복잡도: O(p) + O(c) + O(c log c)

- **최적화 기법**
    - **접두어 길이 제한**: 실제 입력은 짧으므로 p는 작은 상수로 취급 가능 → O(1)
    - **노드에 인기 검색어 캐시 저장**: 각 노드에 k개 후보를 미리 저장하면 전체 탐색을 피할 수 있음 (공간 비용 증가)

### 3.2 데이터 수집 및 업데이트 전략

- **문제점**
    - 사용자가 타이핑할 때마다 실시간으로 트라이 갱신 시, 빈번한 업데이트로 인해 질의 서비스 성능 저하 우려

- **해결 방안**
    - **로그 기반 데이터 수집**: 원본 질의 로그를 저장(append-only)
    - **로그 취합 서버**: 로그 데이터를 주기적으로 집계하여 빈도 정보 업데이트
    - **작업 서버**: 배치 작업으로 새로운 트라이를 생성, 주기적으로(예: 매주) 트라이 캐시 및 DB 스냅샷 갱신

### 3.3 질의 서비스 운영

- **서비스 플로우**
    - 클라이언트 → 로드밸런서 → API 서버
    - API 서버는 **트라이 캐시**에서 자동완성 후보 검색
        - 캐시 미스 시, 트라이 DB에서 데이터 로드 후 캐시 갱신

- **추가 최적화**
    - **AJAX 요청**: 페이지 리로드 없이 비동기 요청
    - **브라우저 캐싱**: 제안 결과를 클라이언트 측에 저장하여 중복 요청 방지
    - **데이터 샘플링**: 모든 요청 로깅 대신 일부만 샘플링하여 리소스 절감

---

## 4. 확장성 및 샤딩 전략

- **트라이 크기 이슈**
    - 트라이가 한 서버에 저장하기 어려울 정도로 커질 수 있음 → **샤딩 필요**

- **샤딩 방법**
    - **첫 글자 기준 샤딩**: 예를 들어, 'a'~'m'과 'n'~'z'로 분리 (최대 26개 서버)
    - **계층적 샤딩**: 두 번째 글자까지 고려해 더 세분화, 단 데이터 분포에 따라 균등 분배가 어려울 수 있음
    - **샤드 맵 매니저**: 각 검색어가 어느 샤드에 저장될지 관리

- **검색어 필터링**
    - 혐오성, 폭력적 등 부적절한 검색어를 제거하기 위해 API 서버와 캐시 사이에 **필터 계층** 추가

---

## 5. 마무리 및 고려사항

- **추가 확장 고려**
    - 다국어 지원 시 유니코드 트라이 구현
    - 국가별 인기 검색어에 따라 **국가별 트라이 및 CDN 배포**
    - 실시간 트렌드 반영: 스트리밍 처리(예: Apache Kafka, Spark Streaming) 도입 가능

- **핵심 포인트**
    - **빠른 응답속도**와 **확장성**을 달성하기 위해 트라이 자료구조 및 캐싱 기법 활용
    - **배치 업데이트**를 통해 실시간 업데이트 부담을 줄이고, 질의 서비스의 응답성을 극대화
    - **샤딩 전략**으로 데이터 분산 처리 및 서버 확장 문제 해결

---

