# 호텔 예약 시스템 설계

## 1. 요구사항

### 기능 요구사항

- 5000개 호텔에 100만 개 객실을 갖춘 호텔 체인을 위한 웹사이트 구축
- 대금은 예약할때 지불
- 호텔 정보 페이지 표시
- 객실 정보 페이지 표시
- 객실 예약/취소 기능
- 관리자용 호텔/객실 추가, 삭제, 갱신 기능
- 초과 예약 허용 (약 10%)
- 객실 가격 유동적

### 비기능 요구사항

- 높은 수준의 동시성 처리 (성수기/이벤트 대응)
- 수 초 이내의 응답 지연 허용

### 시스템 규모 추정

1. 호텔/객실 상세페이지(조회)
2. 예약 정보 페이지(조회)
3. 객실 예약 페이지(트랜잭션 발생)

대략 10%의 사용자가 다음 단계로 진행하고 90% 사용자는 최종 이탈 즉 1 -> 2 -> 3 순으로 QPS 적어짐
사실상 초당 예약 트랜잭션 수는 그다지 높지 않음

---
## 2. 개략적 설계안

### API 설계

#### 호텔 API

- `GET /v1/hotels/{id}`: 호텔 상세 정보 조회
- `POST /v1/hotels`: 호텔 추가 (관리자용)
- `PUT /v1/hotels/{id}`: 호텔 정보 수정 (관리자용)
- `DELETE /v1/hotels/{id}`: 호텔 삭제 (관리자용)

#### 객실 API

- `GET /v1/hotels/{hotelId}/rooms/{roomId}`: 객실 상세 조회
- `POST /v1/hotels/{hotelId}/rooms`: 객실 추가
- `PUT /v1/hotels/{hotelId}/rooms/{roomId}`: 객실 정보 수정
- `DELETE /v1/hotels/{hotelId}/rooms/{roomId}`: 객실 삭제

#### 예약 API

- `GET /v1/reservations`: 사용자 예약 목록 조회
- `GET /v1/reservations/{id}`: 특정 예약 상세 조회
- `POST /v1/reservations`: 신규 예약 요청
- `DELETE /v1/reservations/{id}`: 예약 취소

---

### 데이터 모델

- 관계형 데이터베이스 사용
    - 쓰기보다 읽기 연산이 높음
    - 예약 시스템에서 ACID 중요
- 예약 단위는 `room_id`가 아닌 `room_type_id` (호텔은 특정 객실 유형으로 예약함)
- 주요 테이블: hotel, room_type, room_type_inventory, room_type_rate, reservation
- 주요 속성:
    - `room_type_inventory`: hotel_id, room_type_id, date 기준으로 total_inventory, total_reserved 저장
    - `room_type_rate`: 날짜별 요금 정보
    - `reservation`: 예약 정보 및 상태 관리

---

## 3. 상세 설계

### 동시성 제어
### 1. 같은 사용자가 예약 버튼을 여러번 누른다면?
**클라이언트 측 :** 예약 버튼 중복 클릭 방지

**서버 측 :** 멱등 API 설계 (reservation_id를 키로 사용)

### 2. 여러 사용자가 같은 객실을 동시에 예약하려 한다면?

- **비관적 락**: 해당 레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트 방지
    - 충돌 방지에 효과적이나 확장성 낮음(데드락 발생 가능성 있음)
- **낙관적 락**: version 필드 사용
    - 대부분 상황에 적합, 예약 TPS가 낮은 환경에 유리
    - 데이터 경쟁이 아주 치열한 상황에서는 성능 나쁨
- **DB 제약 조건**:
    - `CHECK (total_inventory - total_reserved >= 0)`

### 캐시 설계

- Redis 캐시 도입
    - Key: `hotelID_roomTypeID_YYYYMMDD`
    - Value: 잔여 객실 수
- TTL, LRU 정책으로 메모리 최적화
- 캐시 미스 시 DB로 fallback

캐시 도입으로 인한 데이터 불일치는 최종적으로 데이터베이스에서 잔여객실 확인을 하므로 문제되지 않음.

### 시스템 확장

- 데이터베이스 샤딩
    - 샤딩 키: `hotel_id`
    - hash 기반 분산
- 고가용성 확보를 위한 다중 리전/가용성 존 구성
- 예약 이력은 cold storage로 이전

### 데이터 일관성

앞의 설계안은 예약 테이블과 잔여 객실 테이블을 동일 DB에 저장하는 하이브리드 접근법이다.

하지만 MSA에 맞게 DB를 각각 분리해야할 경우에 데이터 일관성을 챙기는 방법은 아래와 같음
#### 2단계 커밋 (2PC)

- 중앙 코디네이터가 전체 트랜잭션을 동기적으로 관리함 (원자성 보장)
- 블로킹 발생 쉬움, 하나 멈추면 전체 멈추는 위험 → MSA 부적합.

#### 사가 패턴

- 각 서비스가 로컬 트랜잭션을 수행하고, 실패 시 보상 트랜잭션으로 취소 처리.
- 장점: 비동기 처리 가능하고 서비스 간 결합도 낮음, 확장성 좋음.
- 단점: 보상 로직 직접 구현해야 하고, 중간 실패 복구가 복잡할 수 있음.


