# 7장. 분산 시스템을 위한 유일 ID 생성기 설계
## 목표
분산 시스템에서 사용될 유일 ID 생성기를 설계해라.

## 1단계. 문제 이해 및 설계 범위 확정
- ID의 특성: 유일해야 하고, 정렬 가능해야 한다.
- ID 갱신 규칙: ID는 발급 시간으로 정렬 가능해야 한다.
- ID 타입: 숫자로만 구성되어야 한다.
- 시스템 규모: 초당 10,000개 ID 생성할 수 있어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.

## 2단계. 개략적 설계안 제시 및 동의 구하기
### 분산 시스템에서 유일성이 보장되는 ID를 만드는 방법
- 다중 마스터 복제
- UUID
- 티켓 서버
- 트위터 스노우플레이크 접근법
### 다중 마스터 복제
- 서버마다 ID를 k만큼 증가 (k = 서버 수)
- 장점
  - 규모 확장성 문제 부분 해결 가능: 데이터베이스 수를 늘려 초당 생산 가능 ID 수 늘릴 수 있음
- 단점
  - 여러 데이터 센터에 걸쳐 규모 늘리기 어려움
  - ID의 유일성은 보장되겠지만, 시간 흐름에 맞춰 커지도록 보장할 수 없음
  - 서버 추가/삭제 시 잘 동작하도록 만들기 어려움
### UUID
- 128비트짜리 고유값
- 충돌 가능성 희박
- 서버마다 별도 ID 생성기 사용하여 독립적으로 ID 생성
- 장점
  - 생성 방법 단순: 동시성 이슈 X, 서버 사이 조율 X
  - 규모 확장 용이
- 단점
  - 너무 큰 사이즈
  - 시간 순 정렬 불가
  - 숫자 외 값 포함
### 티켓 서버
- 중앙 집중형 단일 티켓 서버
- 장점
  - 유일성 보장, 숫자로만 구성 쉬움
  - 구현 쉬움
  - 중소 규모 애플리케이션에 적합
- 단점
  - SPOF
  - SPOF를 방지하기 위해 티켓 서버를 여러 대 사용한다면 동기화 이슈 등장
### 트위터 스노우플레이크 접근법
- Divide and Conquer
- 64비트 ID의 구성
  - sign 비트(1bit): 여분 비트, 음수/양수 구분용으로 사용 가능
  - timestamp(41bit): (트위터의) 기원 시각 이후 몇 밀리초가 경과했는지 나타내는 값
  - 데이터센터 ID(5bit): 32(2^5)개 데이터 센터 지원 가능
  - 서버 ID(5bit): 데이터 센터 당 32(2^5)개 서버 사용 가능
  - 일련번호(12bit): ID 생성마다 1씩 증가. 즉, **1ms 경과마다 0으로 초기화**
## 3단계. 상세 설계
### 트위터 스노우플레이크 접근법 기반
- 모든 요구 사항 만족 & 규모 확장 가능
- 정적 값: 데이터센터 ID, 서버 ID
- 동적 값: 타임스탬프, 일련번호
### 타임스탬프
- 시간의 흐름에 따른 값. 즉, 시간 순 정렬 가능
- 이진 형태 <-> UTC 시각
  - 이진수 -> 십진수 -> + 트위터 기원 시각 -> 밀리초 값을 UTC 시각으로 변환
- 41 bit로 표현 가능한 타임스탬프: (2^41)-1 = 대략 69년
  - 따라서 기원 시각을 늦춰서 (트위터의 기원) overflow 발생 시점 미룸
  - 이후에는 기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전해야 함
### 일련번호
- 12bit로 표현 가능한 일련번호: 2^12 = 4096개
- 특정 서버가 같은 밀리초 동한 하나 이상의 ID를 만들어내야만 0보다 큰 값 생성됨
## 4단계. 마무리
- 추가 논의사항
  - 시계 동기화: 하나의 서버가 여러 코어에서 실행 or 여러 서버가 물리적으로 독립된 장비에서 실행 시 모두 같은 시계를 사용한다고 보장할 수 없다. 
  - 각 section의 길이 최적화: 동시성이 낮고, 수명이 긴 애플리케이션이라면 일련번호 길이 줄이고, 타임스탬프 길이 늘리는 것이 효과적
  - 고가용성: 필수 불가결 컴포넌트이므로 아주 높은 가용성 제공 필요
