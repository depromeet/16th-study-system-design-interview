# 14장. 유튜브 설계
## 목표
유튜브 시스템을 설계하라
#### 2020년 조사 결과
- 월간 능동 사용자 수: 20억
- 매일 재생되는 비디오 수: 50억
- 미국 성인의 73% 사용
- 5000만 명의 창작자
- 2019년 기준 광고 수입 150억
- 모바일 인터넷 트래픽의 37% 점유
- 80개 언어 지원
## 1단계. 문제 이해 및 설계 범위 확정
- 주요 기능: 비디오 업로드, 시청
- 클라이언트 종류: 모바일 앱, 웹 브라우저, 스마트 TV
- DAU: 500만 명
- 사용자 평균 소비 시간: 30분
- 다국어 지원 여부: 지원
- 비디오 해상도: 현존하는 비디오 종류와 해상도 대부분 지원
- 암호화 여부: 필요
- 비디오 크기 제한: 최대 1GB
- 클라우드 서비스 활용 가능 여부: 가능
### 요구사항
- 빠른 비디오 업로드
- 원활한 비디오 재생
- 재생 품질 선택 기능
- 낮은 인프라 비용
- 높은 가용성과 규모 확장성, 안정성
- 지원 클라이언트: 모바일 앱, 웹브라우저, 스마트 TV
### 개략적 규모 추정
- DAU: 500만 명
- 사용자 당 하루 평균 시청 비디오 수: 5개
- 비디오 업로드 사용자 수: 10%
- 하루 평균 업로드 수: 1 비디오
- 비디오 평균 크기: 300MB
- 하루 당 필요한 비디오 저장 용량 = 500만 * 10% * 300MB = 150TB
- CDN 비용
  - AWS Cloudfront 기준, 100% 트래픽이 미국에서 발생 시
  - 1GB당 $0.02
  - 500만 * 5비디오 * 0.3GB * $0.02 = $150,000
## 2단계. 개략적 설계안 제시 및 동의 구하기
- 클라우드 서비스 활용: CDN, BLOB storage
  - 적절한 기술을 선택해라.
  - 규모 확장성이 좋은 기존 클라우드 서비스를 활용해서 직접 구현하는 비용 낭비를 하지 마라.
- CDN: 비디오 저장, 재생 시 CDN에서 스트리밍
- API 서버: 비디오 스트리밍 외 모든 요청
### 비디오 업로드 절차

<img alt="image" src="https://github.com/user-attachments/assets/b22805a4-49ad-4624-8d3a-9305804b17a1">

#### a. 비디오 업로드
1. 비디오를 원본 저장소에 업로드
2. 트랜스 코딩 서버가 원본 저장소에서 비디오 꺼내 트랜스코딩 수행
3. 완료 시 다음 절차를 병렬로 수행
   1. 완료된 비디오를 트랜스코딩 비디오 저장소로 업로드
     1. 트랜스코딩 끝난 비디오를 CDN에 업로드
   2. 트랜스코딩 완료 이벤트를 메세지 큐에 삽입
      1. 완료 핸들러가 이벤트 데이터를 큐에서 꺼냄
      2. 완료 핸들러가 메타 데이터 DB와 캐시 갱신
4. API 서버가 단말에 비디오 업로드 완료 및 스트리밍 준비 되었음을 알림

#### b. 메타 데이터 갱신
1. 원본 저장소에 파일이 업로드 되는 동안, 단말은 **병렬적으로** 비디오 메타데이터 갱신 요청을 API 서버에 전송
  - 메타 데이터: 파일 이름, 크기, 포멧 등
2. API 서버는 이 정보로 메타데이터 DB와 캐시 갱신

### 비디오 스트리밍 절차
- 다운로드: 비디오를 단말로 내려받는 것
- 스트리밍: 단말이 원격 비디오로부터 지속적으로 비디오 스트림 전송 받아 영상을 재생하는 것
#### 스트리밍 프로토콜
- 비디오 스트리밍 위해 데이터 전송 시 쓰는 표준화된 통신 방법
  - MPEG-DASH
  - 애플 HLS
  - 마이크로소프트 Smooth Streaming
  - 어도비 HDS
- 프로토콜마다 지원하는 비디오 인코딩 및 플레이어가 다름
- 서비스의 용례에 맞는 프로토콜을 잘 골라라.
## 3단계. 상세 설계
### 비디오 트랜스코딩
- 비디오는 여러 단말에서 호환되는 bitrate와 포맷으로 저장되어야 함
  - bitrate: 비디오 구성 비트가 얼마나 빨리 처리되어야 하는지를 나타내는 단위
  - 높다 == 고화질
- 필요한 이유
  - 원본은 저장 공간을 많이 차지
  - 상당수 단말과 브라우저는 특정 종류의 비디오 포맷만 지원하므로 호환 위해 여러 포맷으로 인코딩 필요
  - 네트워크 대여폭에 따른 화질 지원
  - 네트워크 상황에 따라 비디오가 끊김 없이 재생되도록 화질 자동/수동 변경 지원
- 인코딩 포멧
  - 컨테이너: 비디오 파일, 오디오, 메타데이터 담는 바구니 같은 것 (포맷: .avi, .mov. mp4 등)
  - 코덱: 비디오 화질 보존하면서 파일 크기 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘 (ex: H.264, VP9, HEVC 등)
### DAG 모델
- 유연성 & 병렬성 달성 목적
- 각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하면서 처리 과정의 병렬성을 높이기 위해서는 적절한 수준의 추상화를 도입 필요
  - 클라이언트 프로그래머가 실행할 작업을 손수 정의할 수 있도록 해야 함
- ex) 페이스북 스트리밍 비디오 엔진: DAG 프로그래밍 모델을 도입하여 작업을 단계별로 배열하고 순차/병렬로 실행될 수 있도록 함

<img alt="image" src="https://github.com/user-attachments/assets/157c919a-7254-40bc-bcf4-f0784bf10bb6">

- 검사: 품질, 손상 확인
- 비디오 인코딩: 다양한 해상도, 코텍, 비트레이트 조합으로 인코딩
- 섬네일: 사용자 업로드 이미지 or 자동 추출 이미지로 섬네일 생성
- 워터마크: 비디오 식별정보를 이미지 위에 오버레이
### 비디오 트랜스코딩 아키텍처

<img alt="image" src="https://github.com/user-attachments/assets/6f5b39ba-ed67-4997-91cd-5a12608067b2">

#### 전처리기
1. 비디오 분할
- 비디오 스트림을 GOP 단위로 분할
- GOP: 특정 순서로 배열된 프레임 그룹, 독립적으로 재생 가능, 몇 초 단위
- 단말에 따라 GOP 단위의 비디오 분할 미지원 -> 전처리기가 처리
2. DAG 생성
- 클라이언트 프로그래머 설정 파일에 따라 DAG 구성
3. 데이터 캐시
- 분할된 비디오의 캐시
- 안정성 위해 GOP와 메타 데이터를 임시 저장소에 보관
- 인코딩 실패 시 보관된 데이터 활용
#### DAG 스케줄러
- DAG 그래프를 단계로 분할하여 각각을 작업 관리자의 작업 큐에 삽입
- ex) 1단계: 비디오 추출 => 2단계: 비디오 인코딩 / 섬네일
#### 자원 관리자
- 자원 배분 담당
- 큐 3개, 작업 스케줄러로 구성
  - 작업 큐(가장 높은 우선순위 작업 선택): 실행할 작업이 보관되어 있는 우선순위 큐
  - 작업 서버 큐(최적 작업 서버 선택): 작업 서버의 가용 상태 정보 보관 우선순위 큐
  - 작업 스케줄러: 최적의 작업/서버 조합 골라, 해당 작업 서버가 작업을 수행하도록 지시하는 역할
  - 실행 큐(작업-서버 정보 추가): 현재 실행 중인 작업 및 작업 서버 정보 보관 큐 -> 왜 큐인가?
#### 작업 서버
- DAG에 정의된 작업 수행
- 작업 종류에 따라 작업 서버 구분하여 관리
#### 임시 저장소
- 시스템 종류에 따라 저장할 데이터 유형, 크기, 이용 빈도, 데이터 유효기간 상이
- 비디오/오디오 데이터는 BLOB 저장소가 적절
- 임시 저장소에 보관된 데이터는 비디오 프로세싱 완료 시 삭제
#### 인코딩된 비디오
- 인코딩 파이프라인의 최종 결과물
### 시스템 최적화
- 속도, 안정성, 비용 측면에서 최적화해보자
#### 속도 최적화
- 비디오 병렬 업로드: GOP 단위로 분할하여 병렬적으로 업로드
- 업로드 센터를 사용자 근거리에 지정: CDN을 업로드 센터로 이용하여 근거리 센터 사용
- 모든 절차를 병렬화: 느슨하게 결합된 시스템을 만들어서 병렬성 증가
  - 시스템 결합도 감소 위해 메시지 큐 도입
  - 절차: 원본 저장소 -> 다운로드 모듈 -> 인코딩 모듈 -> 업로드 모듈 -> 인코딩 된 비디오 저장소 -> CDN
  - 각 모듈의 작업이 끝나길 대기하지 않고, 메세지 큐에 보관하여 각 이벤트를 병렬 처리
#### 안정성 최적화
- 미리 사인된 업로드 URL: 허가된 사용자만 올바른 장소에 비디오를 업로드할 수 있도록 pre-signed url 이용
  1. 클라이언트 POST 요청으로 presigned url 발급(해당 URL이 가리키는 객체에 대한 접근 권한 이미 부여)
  2. API 서버가 presigned url 반환
  3. 클라이언트는 해당 URL 위치에 비디오 업로드
- 비디오 보호
  - 디지털 저작권 관리 시스템 고입: 애플 페어플레이, 구글 와이드바인, 마이크로소프트 플레이레디 등
  - AWS 암호화: 비디오 암호화 및 접근 권한 설정 => 재생 시에만 복호화, 허락된 사용자만 시철
  - 워터마크: 소유자 정보 포함한 이미지 오버레이 사용
#### 비용 최적화
- CDN 비용 부담 -> 콘텐츠 인기도, 이용 패턴, 시청 패턴, 비디오 크기 등에 따른 최적화
- 인기 비디오는 CDN 사용, 그 외 비디오 서버 통하여 재생
- 인기 없는 비디오 인코딩 불필요, 짧은 비디오는 인코딩
- 특정 지역에서만 인기 있는 비디오는 다른 지역에 옮길 필요 X
- CDN을 직접 구축하고 ISP와 제휴
### 오류 처리
- 회복 가능 오류: 
  - 특정 비디오 세그먼트 트랜스코딩 실패 등
  - 재시도 및 회복 불가능 시 적절한 오류 코드 반환
- 회복 불가능 오류: 
  - 비디오 포맷 오류 등
  - 해당 비디오에 대한 작업 중단 후 클라이언트에 적절한 오류 코드 반환
- 해결 방법
  - 업로드 오류: 재시도
  - 비디오 분할 오류: 전체 비디오를 서버로 전송 및 서버가 비디오 분할 처리
  - 트랜스코딩 오류: 재시도
  - 전처리 오류: DAG 그래프 재생성
  - DAG 스케줄러 오류: 다시 스케줄링
  - 자원 관리자 큐에 장애 발생: 사본 이용
  - 작업 서버 장애: 다른 서버에서 재시도
  - API 서버 장애: 다른 API 서버에서 재시도
  - 메타데이터 캐시 서버 장애: 다중화 데이터 이용, 서버 교체
  - 메타데이터 DB 서버 장애: 다중화 전략에 따른 복구
## 4단계. 마무리
### 추가 고려사항
- API 계층의 규모 확장성 확보 방안
- 데이터베이스 계층의 규모 확장성 확보 방안
- 라이브 스트리밍
  - 응답 지연 최소화(스트리밍 프로토콜 선정에 유의)
  - 병렬화 필요성 낮음(작은 단위 데이터 실시간으로 빨리 처리)
  - 오류 처리 방안(시간이 오래 걸리면 안됨)
- 비디오 삭제
  - 불법, 선정적 등 비디오 삭제
  - 업로드 과정에서 식별 및 사용자 신고 절차에 따른 판별
