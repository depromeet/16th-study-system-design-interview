# 10장. 실시간 게임 순위표

## 목표

- 온라인 모바일 게임의 순위표를 설계하라.

## 1단계. 문제 이해 및 설계 범위 확정

- 점수 계산 방식: 사용자가 경기에서 승리할 때마다 1점의 포인트를 추가로 획득
- 순위표 표기: 모든 플레이어, 상위 10명의 사용자와 특정 사용자의 순위를 순위표에 표시할 수 있어야 함
    - 시간 여유가 된다면, 사용자 기준 4순위 아래, 위 사용자들끼리 반환하는 방법도 논의
- 순위표 유효 기간: 매달 새로운 토너먼트 시작할 때마다 새로운 순위표 생성
- 토너먼트 참가자 수: DAU 500만 명, MAU 2500만 명
- 토너먼트 기간 동안 평균 진행 경기 수: 10경기
- 두 플레이어 간 동점일 때 순위: 동일 순위 (시간이 된다면, 동점자 순위 가르는 방법 논의)
- 실시간 여부: 실시간 또는 가능한 실시간에 가깝게 결과 표시, 누적된 결과 이력을 보여주는 것은 바람직하지 않음

### 기능 요구사항

- 순위표에 상위 10명의 플레이어를 표시
- 특정 사용자의 순위 표시
- 어떤 사용자보다 4순위 위/아래에 있는 사용자 표시(보너스 문제)

### 비기능 요구사항

- 점수 업데이트는 실시간으로 순위표에 반영
- 일반적인 확장성, 가용성 및 안정성 요구사항

### 개략적 규모 추정

- 게임을 하는 사용자가 24시간 동안 고르게 분포한다고 가정하면 DAU가 500만 명인 게임의 경우 초당 평균 50명의 사용자가 게임을 플레이
- 서로 다른 시간 대 사람들이 동시에 게임을 할 수 있는 북미 지역 기준 저녁 시간이 피크 시간대일 가능성 높음
- 최대 부하 = 평균의 다섯배로 가정 = 초당 250명의 사용자
- 사용자 점수 획득 QPS: 하루 평균 10개 게임 플레이 시, 50 * 10 = 500 (최대 2500)
- 상위 10명 순위표 가져오기 QPS: 각 사용자가 하루 한 번 게임 열고, 상위 10명 순위표는 사용자가 처음 게임을 열 때만 표시 시, QPS = 50

## 2단계. 개략적 설계안 제시 및 동의 구하기

### API 설계

- POST `/v1/scores`
    - 요청 매개변수: user_id, points
    - 사용자 순위 갱신
- GET `/v1/scores`
    - 순위표에서 상위 10명 플레이어 조회
- GET `/v1/scores/{user_id}`
    - 특정 사용자의 순위 조회

### 개략적 설계안

<img alt="image" src="https://github.com/user-attachments/assets/174e1e43-480f-49b0-8de4-2828fd221bd4">

- 클라이언트가 직접 점수를 정하지 않는 이유: 중간자 공격 가능(보안상 안전 X)
- 온라인 포커처럼 서버가 게임 전반을 통솔하는 경우에는 클라이언트가 점수 설정을 위햇 ㅓ게임 서버를 명시적으로 호출할 필요가 없음
- 게임 서비스와 순위표 서버 사이의 메시지 큐 필요 여부
    - **게임 점수가 어떻게 사용되는지에 따라 크게 달라짐**
    - 여러 기능 지원 시 카프카에 데이터를 넣는 것이 합리적일 수 있음
        - 순번제 게임, 멀티 플레이 게임 등
    - 이번 요구사항에서는 없었으므로 사용 X

### 데이터 모델

#### 관계형 데이터베이스

- 규모 확장성이 그다지 중요하지 않고, 사용자 수가 많지 않다면? RDB
- 사용자가 점수 획득: 순위표 테이블 갱신
- 특정 사용자 순위 검색: 점수 기준 정렬하여 순위 매김
- 레코드가 많다면?
    - 사용자 순위 파악 위해 정렬 필요
    - 데이터 지속적인 변경에 캐시 도입 어려움 + 실시간성 보장 어려움
    - 다량의 읽기 부하 처리 어려움
- 최적화 시도: 인덱스, limit 활용
- 한계
    - 특정 사용자의 순위 알기 위해서는 기본적으로 전체 테이블 훑어야 함
    - 순위표 상단에 있지 않은 사용자 순위 찾기 어려움

#### 레디스

- 메모리 기반 키-값 저장소
- 메모리 레벨이므로 빠른 읽기, 쓰기 가능
- 순위표 시스템 설계 문제 해결에 이상적인 정렬 집합 자료구조 제공
- 정렬 집합
    - 저장된 각 요소는 점수에 연결되어 있음
    - 집합 내 원소는 고유해야하지만, 같은 점수는 가능
    - 오름차순 정렬
    - 내부적으로 해시테이블과 스킵 리스트 자료구조 사용
        - 해시 테이블: 사용자 점수 저장
        - 스킵 리스트: 특정 점수를 딴 사용자 목록 저장
            - 스킵 리스트: 빠른 검색을 가능하게 하는 자료 구조
                - 정렬된 연결 리스트에 다단계 색인 배치
                - 기본 연결 리스트: 삽입/조회/삭제 -> O(n)
                - 연산을 빠르게 실행되도록 하기 위해
                    - 중간 노드를 하나씩 건너뛰는 1차 색인
                    - 1차 색인 노드를 하나씩 건너뛰는 2차 색인을 추가
    - 정렬 집합은 삽입이나 갱신 연산을 할 때 모든 원소가 올바른 위치에 자동으로 배치되며 새 원소를 추가하거나 기존 원소를 검색하는 연산의 시간 복잡도 = O(logn) -> 관계형 데이터베이스보다 성능 좋음
- 구현
    - ZADD: 기존에 없던 사용자를 집합에 추가, 기존 사용자는 점수 갱신 -> O(logn)
    - ZINCRBY: 사용자 점수를 지정된 만큼 증가 -> logn
    - ZRANGE/ZREVERANGE: 점수에 따라 정렬된 사용자 중 특정 범위에 드는 사용자들 조회 -> O(logn + m) (n=정렬 집합 크기, m=가져올 항목 수)
    - ZRANK/ZREVRANK: 오름차순, 내림차순 정렬 시 특정 사용자 위치 - O(logn)

#### 저장소 요구사항

- 최소한 사용자 ID와 점수는 저장해야 함
- 2500만 명 모두가 최소 한 번 이상 게임에서 승리하는 시나리오를 가정
- ID가 24자 문자열, 점수가 16bit 정수 -> 26byte 필요
- MAU당 26byte * 2500만 = 6억 5000만 byte - 650MB 저장공간 필요
- 스킵 리스트 구현에 필요한 오버헤드와 정렬 집합 해시를 고려해 메모리 사용량을 두 배로 늘려도 한 대로 감당하기 어려움
- CPU 및 I/O 사용량
    - 갱신 연산의 최대 QPS = 2500/sec -> 단일 레디스 서버로도 충분히 감당
- 데이터 영속성
    - 데이터를 디스크에 영속적으로 보관하는 옵션도 지원
    - 디스크에서 데이터를 읽어 대규모 레디스 인스턴스를 재시작하는 건 시간 소요 -> 주로 읽기 사본 배치

## 3단계. 상세 설계

- 클라우드 서비스 사용 여부
    - 자체 서비스 이용
    - AWS 같은 클라우드 서비스 업체 이용
- 레디스의 규모 확장 문제
- NoSQL을 대안으로 사용하는 방안
- 기타 고려 사항

### 클라우드 서비스 사용 여부

#### 1. 자체 서비스를 이용하는 방안

- 매월 졍렬 집합을 생성하여 해당 기간으 ㅣ순위표 저장
    - 사용자, 점수 정보
- 사용자 세부 정보는 MySQL 데이터베이스에 저장
- 순위표 조회 API 서버는 순위 데이터와 데이터베이스의 사용자 정보를 조회
- 장기적으로 비효율적인 작업이라면, 상위 사용자 10명의 세부 정보를 저장한느 프로필 캐시를 두어 해결

#### 2. 클라우드 서비스를 이용하는 방안

- 아마존 API gateway와 AWS Lambda 사용
    - API Gateway -> RESTful API의 HTTP 엔드포인트를 정의하고, 아무 백엔드 서비스나 연결 가능
    - 람다 함수와 연결
- Lambda
    - 서버리스 컴퓨팅 플랫폼
    - 서버를 직접 준비하거나 관리할 필요 없이 코드 실행
    - 람다는 필요할 때만 실행되어 트래픽에 따라 규모가 자동 확장
    - 레디스를 호출할 수 있도록 클라이언트 제공
    - DAU 성장세에 맞춰 자동으로 서비스 규모 확장
- 동작
    - 게임은 API 게이트웨이를 호출하고, 이 게이트웨이는 적절한 람다 함수를 호출
    - 람다 함수는 스토리지 계층의 명령을 호출하여 얻은 결과를 API 게이트웨이에 반환
    - API 게이트웨이는 그 결과를 애플리케이션에 전달

### 레디스 규모 확장

- 5백만 DAU면 한 대의 레디스 캐시 서버로 충분히 지원
- 5억 DAU라면, 최악의 경우 65GB의 저장 용량, 250000 QPS 질의 처리 가능해야 함 -> 샤딩

#### 데이터 샤딩 방안

1. 고정 파티션 ✅
    - 순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안
    - 순위표 전반에 점수가 고르게 분포되어있어야 함
    - 특정 사용자 위치 알아내는 방법
      a. MySQL 질의
      b. 사용자 ID와 점수 사이 관계를 저장하는 2차 캐시 활용
    - 사용자 점수 변경 시 샤드 이동 발생 유의
    - 특정 사용자 순위 알기 위해서는 해당 샤드보다 높은 점수 커버하는 모든 샤드의 모든 사용자 수 알아야 함
        - 특정 샤드 내 사용자 수는 `info keyspace` 명령으로 O(1) 시간에 알 수 있음
2. 해시 파티션
    - 레디스 클러스터 사용 -> 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공
    - 사용자들의 점수가 특정 대역에 과도하게 모여 있는 경우 효과적
    - 안정 해시를 사용하진 않지만, 각각의 키가 특정 해시 슬롯에 속하도록 하는 샤딩 기법 사용
        - 모든 키를 재분배하지 않아도 클러스터에 쉽게 노드 추가, 제거 가능
    - 문제점
        - 상위 k개 결과 반환해야 하는 경우, 각 샤드에서 많은 데이터 읽고, 정렬해야하므로 지연 시간 증가
        - 가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과 계산 가능하므로 지연 시간 증가
        - 특정 사용자 순위 결정할 간단한 방법 없음

#### 레디스 노드 크기 조정

- 쓰기 작업이 많은 애플리케이션에는 많은 메모리 필요: 장애 대비해 스냅샷을 생성할 때 필요한 모든 쓰기 연산 감당할 수 있어야 함
- 쓰기 연산이 많은 애플리케이션에는 메모리를 두 배 할당
- redis-benchmark: 여러 클라이언트가 동시에 여러 질의를 실행하는 것을 시뮬레이션하여 주어진 하드웨어로 초당 얼마나 많은 요청을 처리할 수 있는 지 측정

### 대안: NoSQL

- 요구사항
    - 쓰기 연산에 최적화되어 있다.
    - 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능하다.
- DynamoDB: 안정적 성능과 뛰어난 확장성을 제공하는 완전 관리형 NoSQL 데이터베이스
    - 기본 키 이외의 속성을 활용하여 데이터 효과적으로 질의 가능하도록 전역 보조 색인 제공
        - 전역 보조 색인: 부모 테이블의 속성들로 구성되지만, 기본 키는 부모 테이블과 다르다.
- 순위표와 사용자 테이블을 비정규화하여 필요한 모든 정보를 담았다고 가정
    - 규모 확장의 어려움
    - 레코드 많아지면 상위 점수 찾기 위해 전체 테이블 찾으므로 성능 저하
- game_name#{year-month}을 파티션 키로 점수를 정렬 키로 사용한다고 가정
    - 부하 높을 때 문잔
    - DynamoDB는 안정 해시를 사용하여 여러 노드에 데이터 분산
    - 각 항목은 파티션 키에 따라 선정된 노드에 저장
    - 하지만, 지금의 설계는 한 달치 데이터가 동일한 파티션에 저장 및 핫 파티션이 됨
- 데이터를 n개 파티션으로 분할하고 파티션 번호를 파티션 키에 추가: 쓰기 샤딩
    - 읽기/쓰기 모두 복잡
- 얼마나 많은 파티션을 두어야 하나
    - 쓰기 볼륨 또는 DAU 기준으로 결정
    - 파티션이 받는 부하와 읽기 복잡도 사이에는 타협적인 부분 존재
    - 한 달 데이터가 여러 파티션에 분산 -> 한 파티션의 부하 감소, 특정 달 데이터 읽으려면 모든 파티션에 질의하므로 구현은 복잡
- 파티션 수는 어떻게 정하나?
    - 파티션이 많으면 각 파티션 부하는 감소, 최종 순위표 위한 조회 복잡성은 증가
- 상대적 순위 개선안
    - 사용자 위치의 백분위 수 활용

## 4단계. 마무리

### 더 빠른 조회 및 동점자 순위 판정 방안

- 레디스 해시를 사용하면 문자열 필드와 값 사이의 대응 관계 저장 가능

1. 순위표에 표시할 사용자 ID와 사용자 객체의 대응 관계를 저장
2. 두 사용자의 점수가 같은 경우 누가 먼저 점수를 받았는지에 따라 순위 결정 가능
    - 사용자 ID와 사용자가 마지막으로 승리한 경기의 타임스탬프 사이의 대응관계 저장

### 시스템 장애 복구

- 레디스 클러스터에도 대규모 장애는 발생
- 사용자 게임 이길 때마다 MySQL에 타임스탬프와 함께 그 사실 기록 -> 스크립트 만들어서 복구 가능
