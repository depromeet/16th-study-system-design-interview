# 4장: **처리율 제한 장치 설계**

## 1. 처리율 제한 장치란
처리율 제한 장치는 클라이언트 또는 서비스가 보내는 요청의 속도를 제어하는 메커니즘이다. 주어진 시간 내 특정 한도를 초과하는 요청을 제한하여 서버 자원을 보호하고 안정적인 서비스 운영을 가능하게 한다.
**예시**
- 트위터는 3시간 동안 300개의 트윗만 올릴 수 있도록 제한한다.
- 구글 독스는 API 사용자당 분당 300 회의 read 요청만 혀용한다.

## 2. 필요성
- **DoS 공격 방지**: 악의적인 과도한 요청을 막아 자원 고갈을 방지.
- **비용 절감**: 추가 요청에 대한 처리를 제한 함으로써 우선순위가 높은 API에 더 많은 자원을 할당할 수 있음(제 3자 api에 사용료를 지불하고 있는 경우 중요)
- **서버 과부하 방지**: 비정상 트래픽을 걸러냄으로써 정상적인 사용자를 보호하고 시스템 성능 유지.

## 3. 처리율 제한 장치의 배치 위치
1. **클라이언트 측**: 위변조 가능성이 있어 권장되지 않음.
2. **서버 측**: API 서버에서 직접 제한. 알고리즘 자유롭게 선택 가능
3. **미들웨어(API Gateway)**:
    - MSA 환경에서는 API Gateway에서 처리율 제한을 관리하는 것이 일반적
    - SSL 종단, 사용자 인증, IP 제한 기능과 함께 통합 운영 가능

처리율 제한 장치를 어디에 배치할 것인지에 대한 질문에 정답은 없지만, 일반적으로 적용되는 몇 가지 지침을 참고할 것

1. 현재 사용 기술 스택을 점검하고, 현재 사용하는 프로그래밍 언어가 서버 측 구현을 지원하기에 충분한 효율이 나올지 점검할 것
2. 각 프로젝트에 맞는 처리율 제한 알고리즘을 찾을 것(단 ,제 3자가 제공하는 게이트웨이를 사용한다면 제약이 있을 수 있음)
3. 마이크로서비스로 설계된 경우 API 게이트웨이에 배치해야할 수도 있음
4. 처리율 제한 서비스를 직접 만드는 데 시간이 걸리는 것을 고려할 것

## 4. 처리율 제한 알고리즘
각 알고리즘은 특정한 트래픽 패턴과 요구 사항에 맞게 선택해야 한다.

### 1. 토큰 버킷 
- 정해진 비율로 토큰을 공급하며, 요청이 도착할 때마다 토큰을 소비
- 남은 토큰이 있으면 요청 허용, 없으면 거부
- **장점**: 버스트 트래픽 대응 가능, 메모리 효율적
- **단점**: 토큰 공급률과 버킷 크기 조정이 어려움

### 2. 누출 버킷
- 요청을 큐에 저장하고 일정한 속도로 처리
- 큐가 가득 차면 초과 요청은 버려짐
- **장점**: 큐 사이즈가 제한되어 있으므로 메모리 사용량 측면에서 효율적. 고정된 처리율로 안정적인 처리율 유지
- **단점**: 급격한 트래픽 증가 시 최신 요청이 버려질 수 있음.

### 3. 고정 윈도 카운터
- 일정한 시간 단위를 정해 해당 기간 내 요청 횟수를 제한.
- **장점**: 간단한 구현, 메모리 효율적.
- **단점**: 윈도 경계에서 트래픽이 몰릴 경우 초과 허용 가능.

고정 윈도 카운터는 일정한 요청 패턴이 유지되는 환경에 적합하다.
트래픽이 갑자기 몰리는 버스트 트래픽에서는 적절하지 않음(이러한 경우에는 이동 윈도 카운터 같은 알고리즘이 적합)

### 4. 이동 윈도 로깅 
- 각 요청의 타임스탬프를 저장하고, 특정 시간 내 요청 개수를 검사.
- **장점**: 정확한 제한 가능
- **단점**: 많은 타임스탬프 저장 필요, 메모리 부담 증가(거부된 요청의 타임스탬프도 보관하기 때문)

### 5. 이동 윈도 카운터 
- 고정 윈도 카운터 + 이동 윈도 로깅
- 최근 일정 기간의 요청 수를 계산하여 제한
- **장점**: 트래픽 급증 대응 가능, 메모리 사용 최적화.
- **단점**: 정확도가 100%는 아님(Cloudflare 실험 결과 오차율 0.003%).

## 5. 처리율 제한 시 고려 사항
- **HTTP 429 응답 (Too Many Requests)**: 초과 요청 발생 시 클라이언트에 응답
- **HTTP 헤더 사용**:
    - `X-Ratelimit-Remaining`: 남은 요청 수
    - `X-Ratelimit-Limit`: 제한 값
    - `X-Ratelimit-Retry-After`: 다시 요청 가능 시점

## 6. 분산 환경에서의 구현
- **Race Condition 해결**:
    - Redis **sorted set** 활용 가능
    - Lua 스크립트를 사용하여 원자적 연산 수행
- **동기화(Synchronization) 문제 해결**:
    - 중앙 집중형 Redis 사용
    - Sticky session으로 특정 서버에 요청을 고정(비추천)
- **성능 최적화**:
    - Edge 서버 배치로 지연시간 최소화

## 7. 추가 고려 사항
- **경성(Hard) vs 연성(Soft) 제한**: 상황에 따라 엄격한 제한 또는 유연한 제한 설정 가능.
- **다양한 기준 적용 가능**: 사용자 ID, IP 주소, API 엔드포인트별 제한.
- **클라이언트 최적화**:
    - API 호출 횟수 줄이기 위한 캐싱 사용.
    - 백오프 전략 적용하여 재시도 간격 조정.

