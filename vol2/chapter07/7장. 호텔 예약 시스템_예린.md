# 7장. 호텔 예약 시스템

## 목표

호텔 체인의 예약 시스템을 설계하라.

- 에어비앤비 시스템 설계
- 항공권 예약 시스템 설계
- 영화 티켓 예매 시스템 설계

## 1단계. 문제 이해 및 설계 범위 확정

- 시스템 규모: 5000개 호텔에 100만 개 객실 갖춘 호텔 체인 대상
- 대금 지불 시점: 예약 시 지불
- 예약 시스템: 웹 사이트, 앱
- 예약 취소 가능 여부: 가능
- 10% 초과 예약 가능: 일부 고객 취소를 예상하여 초과 예약 허용
- 다음 사항들에 집중
    - 호텔 정보 페이지 표시
    - 객실 정보 페이지 표시
    - 객실 예약 지원
    - 호텔이나 객실 정보를 추가/삭제/갱신하는 관리자 페이지 지원
    - 초과 예약 지원
- 객실 가격은 유동적: 당일 여유에 따라 가격 변동

### 비기능 요구사항

- 높은 수준의 동시성 지원: 성수기, 대규모 이벤트 기간에는 일부 인기 호텔의 특정 객실을 예약하려는 고객 몰림
- 적절한 지연 시간: 응답 시간에 대해 약간의 지연은 허용

### 개략적 규모 추정

- 총 5000개 호텔, 100만 개 객실 가정
- 평균적으로 사용 중인 객실 비율 = 70%
- 평균 투숙 기간 = 3일
- 일일 예상 예약 건수 = (100만 * 0.7) / 3 = 약 240000
- 초당 예약 건수 = 240000 / 10^5 = 약 3 TPS
- 시스템 내 모든 페이지의 QPS
    - 호텔/객실 상세 페이지: 사용자가 호텔/객실 정보를 확인 (조회)
    - 예약 상세 정보 페이지: 사용자가 날짜, 투숙 인원, 결제 방법 등의 상세 정보를 예약 전에 확인 (조회)
    - 객실 예약 페이지: 사용자가 예약 버튼을 눌러 객실 예약 (트랜잭션 발생)
- 사용자 이탈 정도
    - 약 10% 사용자가 다음 단계 진행
    - 90% 사용자는 최종 단계에 도달하기 전에 흐름 이탈
    - 역 추정: 객실 예약 페이지(3 QPS) -> 예약 상세 페이지(30 QPS) -> 객실 상세 페이지(300 QPS)

## 2단계. 개략적 설계안 제시 및 동의 구하기

- API 설계
- 데이터 모델
- 개략적 설계안

### API 설계

- RESTful하게 나열해보자.
- 호텔 관련 API

  | API | description  |
    |-----|--------------|
  | GET `/v1/hotels/{id}` | 호텔의 상세 정보 조회 |
  | POST `/v1/hotels` | 신규 호텔 추가 (직원 권한) |
  | PUT `/v1/hotels/{id}` | 호텔 정보 갱신 (직원 권한) |
  | DELETE `/v1/hotels/{id}` | 호텔 정보 삭제 (직원 권한) |

- 객실 관련 API

  | API                                 | description      |
    |-------------------------------------|------------------|
  | GET `/v1/hotels/{id}/rooms/{id}`    | 객실 상세 정보 조회      |
  | POST `/v1/hotels/{id}/rooms`        | 신규 객실 추가 (직원 권한) |
  | PUT `/v1/hotels/{id}/rooms/{id}`    | 객실 정보 갱신 (직원 권한) |
  | DELETE `/v1/hotels/{id}/rooms/{id}` | 객실 정보 삭제 (직원 권한) |

- 예약 관련 API

  | API                            | description       |
    |--------------------------------|-------------------|
  | GET `/v1/reservations`         | 로그인 사용자의 예약 이력 반환 |
  | GET `/v1/reservations/{id}`    | 특정 예약의 상세 정보 반환   |
  | POST `/v1/reservations`        | 신규 예약             |
  | DELETE `/v1/reservations/{id}` | 예약 취소             |

    - 신규 예약 접수 시 `reservationID`를 함께 전달
        - 멱등 키: 이중 예약 방지

### 데이터 모델

- 질의
    - 호텔 상세 정보 확인
    - 지정된 날짜 범위에 사용 가능한 객실 유형 확인
    - 예약 정보 기록
    - 예약 내역 또는 과거 예약 이력 정보 조회
- 시스템 규모 자체는 크지 않지만, 대규모 이벤트가 있는 경우에는 트래픽 급증할 수 있음
- 관계형 DB
    - 읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름 지원
    - 사이트 방문자 > 실제 예약 사용자
    - NoSQL 데이터베이스는 대체로 쓰기 연산에 최적화
    - 관계형 DB는 읽기가 압도적인 작업 흐름은 충분히 잘 지원
    - 관계형 DB는 ACID 속성 보장
        - 예약 시스템에서 중요: 잔액 부족 문제, 이중 청구 문제, 이중 예약 문제 등 방지
    - 관계형 DB를 사용하면 데이터 쉽게 모델링
    - 비즈니스 데이터 구조를 명확하게 표현, 엔티티 간 관계를 안정적으로 지원
- 스키마 설계시 유의
    - reservation.status: pending, paid, refunded, canceled
    - room_id & room_type_id: 호텔은 특정 유형은

### 개략적 설계안

- 마이크로서비스 아키텍처 사용

<img alt="image" src="https://github.com/user-attachments/assets/1b11e27b-121b-4af6-a7f3-c907a83db456">

## 3단계. 상세 설계

- 개선된 데이터 모델
- 동시성 문제
- 시스템의 규모 확장
- 마이크로서비스 아키텍처에서의 데이터 일관성 문제에 대한 해결 방안

### 개선된 데이터 모델

- 예약 API 호출 인자 `roomID` -> `roomTypeID`
- 스키마 변경

<img alt="image" src="https://github.com/user-attachments/assets/0ce2a654-6834-4ac6-bc13-ea3e1dd0765e">

- 저장 용량 추정
    - 레코드 수 = 5000개 호텔 * 20개 객실 유형 * 2년 * 365일 = 73000만 개
    - 레코드 수는 많지 않지만, SPOF 방지 목적으로 데이터베이스 다중화
    - 고가용성 달성 목적으로 AZ 여러 곳 사용
- 예약 가능 여부 조회
    - `if ((total_reserved + ${numberOfRoomsToReserve}) <= 110% * total_inventory)`
- 만약 예약 데이터가 단일 데이터베이스에 담기에 너무 크면 어떻게 하시겠어요?
    - 현재 및 향후 예약 데이터만 저장. 예약 이력은 자주 접근하지 않으므로 아카이빙하거나 냉동 저장소로 이동
    - 데이터베이스 샤딩
        - 가장 자주 사용되는 질의는 예약 하거나, 투숙객 이름으로 예약을 확인하는 질의
        - 두 질의 모두 우선 호텔을 먼저 알아야 하므로, hotel_id가 샤딩 키로 적합
            - hash(hotel_id) % number_of_reserves로 샤딩

### 동시성 문제

1. 같은 사용자가 예약 버튼을 여러 번 누를 수 있다.
2. 여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.

#### 해결방안 (1)

- 클라이언트 측 구현
    - 이중 클릭 방지: 클라이언트가 요청을 전송하고 난 다음에 "예약" 버튼 회색 표시, 숨김, 비활성화
        - 사용자가 자바스크립트를 비활성화하면 클라이언트 측 확인 절차는 우회 가능
- 서버 측 구현
    - 멱등 API: 예약 API 요청에 멱등 키를 추가
        - 멱등 API: 몇 번을 호출해도 같은 결과 내는 API

        1. 고객이 예약 세부 정보를 입력하고 '계속' 버튼을 누르면 예약 서비스는 예약 주문을 생성
        2. API는 반환 결과에 전역적 유일성을 보증하는 ID 생성기가 만든 reservation_id를 주문서에 담아서 반환
        3. reservation_id(PK)를 넣어서 검토가 끝난 예약을 전송
        4. 사용자가 예약 버튼을 한 번 더 누르면 reservation_id가 PK이기 때문에 기본키 제약조건에 위반되어 새로운 레코드를 생성하지 않는다.

#### 해결방안 (2)

- 비관적 락
    - 사용자가 레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술
    - 타 사용자는 락을 건 사용자가 변경 마치고 해제하기까지 대기해야함
    - SELECT .. FOR UPDATE
    - 장점
        - 애플리케이션 변경 중/변경 끝난 데이터 갱신 방지
        - 구현 쉽고, 모든 갱신 연산을 직렬화하여 충돌을 방지
        - 데이터에 대한 경합이 심할 때 유용
    - 단점
        - 여러 레코드에 락을 걸면 교착 상태 발생 가능
        - 교착 상태 생기지 않는 애플리케이션 코드 작성은 까다로울 수 있음
        - 확장성이 낮음
        - 트랜잭션이 오래 락을 해제하지 않고 있으면 다른 트랜잭션은 접근 불가함
        - 트랜잭션 수명이 길거나 많은 엔티티에 관련된 경우, 데이터베이스 성능에 심각한 영향
- 낙관적 락
    - 여러 사용자가 동시에 같은 자원을 갱신하려는 시도를 허용
    - 버전 번호와 타임스탬프 방식이 있음
    - 비관적 락과 달리 데이터베이스에 락을 걸지 않으므로 빠른 대신, 동시성 수준이 높으면 성능 급격하게 나빠짐
        - 사용자 경험 저하
    - 장점
        - 애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.
        - 데이터베이스 자원에 락을 걸 필요가 없다.
        - 버전 번호를 통해 데이터 일관성을 유지할 책임은 애플리케이션에 있다.
        - 낙관적 락은 경쟁이 치열하지 않은 상황에 적합하다.
        - 락을 관리하는 비용 없이 트랜잭션 실행이 가능하다.
    - 단점
        - 데이터 경쟁이 치열한 상황에서는 성능이 좋지 않다.
- 데이터베이스 제약 조건
    - 조건문을 제약 조건으로 설정하여 데이터 생성 시점에 위반 여부 검증
    - 장점
        - 구현이 쉬움
        - 데이터에 대한 경쟁이 심하지 않을 때 잘 동작
    - 단점
        - 낙관적 락처럼 데이터 경쟁 심하면 실패 연산 수 증가로, 사용자 경험 저하
        - 데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전 통제 어려움
        - 제약 조건을 허용하지 않는 데이터베이스도 있으므로, 데이터베이스를 다른 제품으로 교체 시 문제 발생

### 시스템 규모 확장

- 만약 호텔 예약 시스템이 해당 호텔 웹사이트에만 연도오디는 것이 아니라 외부 유명한 여행 예약 웹사이트와 연동되어야 한다면 어떨깡?
    - QPS 급격하게 증가 가능 (1000배 증가 가정)
    - **시스템 부하가 높을 때에는 무엇이 병목이 될 수 있는지 이해해야 한다.**
- 무상태 서버는 확장에 용이하지만, 상태 정보가 보관되는 데이터베이스는 단순히 데이터베이스 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없다.

#### 데이터베이스 샤딩

- 샤딩: 데이터베이스 여러 대에 물리적으로 데이터를 분산시켜서 저장하는 아이디어
- 어떻게 분배할 것인가?
    - 대부분의 질의는 hotel_id를 필터링 조건을 사용, 따라서 샤딩 조건으로 사용
    - 16개 샤드를 사용한다면, 30000 / 16 = 1875 QPS

#### 캐시

- 호텔 잔여 객실 데이터의 특징: 현재 & 미래 데이터만 중요
- 데이터 보관 시 낡은 데이터는 자동적으로 소멸되도록 TTL 설정
- 이력 데이터는 다른 데이터베이스를 통해 질의
    - 레디스는 이러한 상황에 적합 TTL과 LRU 캐시 교체 정책을 사용하여 메모리를 최적으로 활용
- 데이터 로딩 속도와 데이터베이스 확장성이 문제되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 계층에서 실행되도록 할 수 있다.
- 요청 가운데 일부만 잔여 객실 데이터베이스가 처리하고, 나머지는 캐시가 담당하여 부하 분산
- 예약 서비스: 잔여 객실 관리 API 제공 (읽기 > 쓰기)
    - 지정된 호텔과 객실 유형, 주어진 날짜 범위에 이용 가능한 객실 수 질의
    - 객실 예약 후 total_reserved 1 증가
    - 고객이 예약 취소하면 잔여 객실 수 갱신
- 잔여 객실 캐시: 모든 잔여 객실 관리에 필요한 질의는 레디스로 구현되는 잔여 객실 캐시로 옮김. 사전에 잔여 객실 정보를 캐시에 미리 저장
    - 키: hotelID_roomTypeID_{date}
    - 값: 주어진 호텔 ID, 객실 유형 ID, 날짜에 맞는 잔여 객실 수
- 잔여 객실 데이터베이스: 가장 최신의 데이터 보관
- 캐시의 데이터 일관성 문제
    - 잔여 객실 데이터에 대한 변화를 데이터베이스에 먼저 반영하므로 캐시에는 최신 데이터가 없을/반영이 안되었을 가능성이 있다.
- 장점
    - 읽기 질의를 캐시가 처리하므로 데이터베이스의 부하 크게 감소
    - 읽기 질의를 메모리에서 실행하므로 높은 성능 보장
- 단점
    - 데이터베이스와 캐시 사이의 데이터 일관성 유지가 어려운 문제
    - 데이터 불일치가 사용자 경험에 어떤 영향을 줄지 신중하게 따져봐야 함

#### 서비스 간 데이터 일관성

- 마이크로서비스 기반 아키텍처는 예약 서비스가 예약 및 잔여 객실 API를 모두 담당하도록 하고, 예약 테이블과 잔여 객실 테이블을 동일한 관계형 데이터베이스에 저장하는 하이브리드 접근법을 채택
- 하지만, 제대로된 마이크로서비스 아키텍처라면 독자적인 데이터베이스를 갖추고 있어야 하는 거 아닌가?
    - 데이터베이스 일관성 문제 때문!
  - 만약, 독자적인 데이터베이스를 가지면서 일관성 문제를 해결하려면 다음 참고
        - 2단계 커밋: 2PC는 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜
            - 모든 노드가 성공/실패에 따라 트랜잭션 마무리 보증
            - 비중단 실행이 가능한 프로토콜이 아니므로, 어느 한 노드에 장애가 발생하면 복구때까지 중단되므로 성능이 뛰어나진 않음
        - 사가: 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮는 것
            - 각 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만들어 전송
            - 한 트랜잭션이라도 실패하면 사가는 그 이전 트랜잭션을 전부 되돌리는 트랜잭션들을 순차적으로 실행
        - 2PC는 여러 노드에 걸친 하나의 트랜잭션으로 ACID 속성을 만족시킨다면, 사가는 각 단계가 하나의 트랜잭션이라서 결과적 일관성에 의존
- 마이크로서비스 간 데이터 불일치 해결 위한 복잡한 메커니즘은 시스템 전체의 복잡성 증가. 증가한 복잡성이 그만한 가치가 있는지 결정하는 것은 설계자의 몫
    - 그래서 복잡성 대신 동일 데이터베이스에서 관리하기로 결정한 것

## 4단계. 마무리
