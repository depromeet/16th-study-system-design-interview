# 주변 친구 서비스 설계 
---

## 1. 문제 이해 및 설계 범위 확정

### 기능 요구사항
- **모바일 앱 제공:**
    - 사용자는 자신의 주변 친구 목록을 확인할 수 있어야 함.
    - 친구 목록에는 각 친구까지의 직선 거리와 마지막으로 위치가 갱신된 시각이 포함됨.
    - 목록은 몇 초 단위(30초 주기)로 갱신되어야 함.

- **위치 기준 및 조건:**
    - 기본 주변 범위: 5마일(8km) 이내 (사용자가 설정 가능).
    - 친구 관계에 있는 사용자 중, 10분 이상 비활성 상태인 경우 목록에서 제외.
    - 사용자 이동 이력은 추후 기계 학습 등 다양한 용도로 활용할 수 있도록 보관.

### 비기능 요구사항
- **낮은 지연 시간:**
    - 위치 변화가 빠르게 반영되어야 하며, 몇 초 내에 업데이트가 완료되어야 함.
- **안정성:**
    - 시스템 전체는 안정적이어야 하나, 일부 데이터 유실은 허용.
- **결과적 일관성:**
    - 강한 일관성이 아닌 최종 일관성으로 충분함.
    - 복제본 데이터가 원본과 동기화되기까지 몇 초의 지연 허용.

### 개략적 규모 추정
- **앱 이용자 수:** 약 10억 명, 그 중 10%가 주변 친구 기능 사용 → 약 1억 DAU.
- **동시 접속 사용자:** DAU의 10% → 약 1,000만 명.
- **위치 업데이트:**
    - 사용자당 30초 주기로 위치 전송 → 초당 약 334,000건의 위치 업데이트.
- **평균 친구 수:** 사용자당 약 400명.
- **페이지당 표시:** 한 페이지에 20명의 친구 정보 제공.

---

## 2. 개략적 설계안 및 시스템 구성 요소

### 주요 구성 요소
- **로드밸런서 :**
    - RESTful API 서버와 웹소켓 서버로 트래픽을 분산.

- **RESTful API 서버:**
    - 친구 추가/삭제, 사용자 정보 갱신 등의 요청 처리.
    - 무상태(stateless) 서버 클러스터로 구성.

- **웹소켓 서버:**
    - 실시간 위치 업데이트 및 초기화 시 주변 친구의 현재 위치 전송.
    - 유상태 서버 클러스터로서, 각 클라이언트와 지속적인 연결 유지.
    - 새로운 위치 이벤트를 받아 각 친구와의 거리를 계산 후, 검색 범위 내에 있을 경우 클라이언트로 전송.

- **레디스 위치 정보 캐시:**
    - 활성 상태 사용자의 최신 위치 정보를 저장.
    - **데이터 형식:**
        - 키: 사용자 ID
        - 값: {latitude, longitude, timestamp}
    - TTL을 사용하여 일정 시간 후 비활성 사용자 정보 자동 삭제.
    - 레디스 클러스터 사용 시, 데이터가 여러 해시 슬롯에 분산되지만 조회는 병렬로 처리되어 개별 노드 부하가 완화됨.

- **사용자 데이터베이스:**
    - 사용자 프로필과 친구 관계 정보를 저장.
    - 관계형 DB 또는 NoSQL 모두 사용 가능하며, 샤딩 전략 적용.

- **위치 이동 이력 데이터베이스:**
    - 사용자의 위치 변경 이력을 기록.
    - 높은 쓰기 부하와 수평적 확장이 가능해야 하므로, Cassandra와 같은 데이터베이스 채택.
    - 최종 일관성 모델 적용.

- **레디스 Pub/Sub 서버:**
    - 각 사용자의 위치 변경 이벤트를 전용 채널에 발행.
    - 해당 채널을 구독한 웹소켓 서버가 친구의 위치 변경 내역을 수신하여 클라이언트에 전달.
    - 대규모 구독자 관리 및 메시지 전파를 위해 분산 클러스터와 안정 해시(Consistent Hashing) 기법 적용.

---

## 3. 서버-클라이언트 간 실시간 통신 프로토콜

### WebSocket
- **특징:**
    - 클라이언트와 서버 간 양방향 실시간 통신.
    - 연결을 지속적으로 유지하여 낮은 지연 시간 보장.
- **적용:**
    - 위치 변경 이벤트를 실시간으로 친구에게 전파.

### HTTP (Long Polling)
- **특징:**
    - 단순한 HTTP 프로토콜 기반.
    - 주기적 요청으로 실시간성이 떨어지고, 서버 부하가 증가할 수 있음.
- **적용:**
    - 실시간 업데이트가 필수적이지 않은 경우 대안으로 고려 가능.

### Server-Sent Events (SSE)
- **특징:**
    - 서버가 클라이언트로 단방향 스트림 전송.
    - HTTP 기반으로 기존 인프라와 호환성 높음.
- **단점:**
    - 양방향 통신에는 부적합.

---

## 4. 데이터 모델 및 샤딩 전략

### 위치 정보 캐시 (Redis)
- **저장 방식:**
    - 사용자 ID를 키로 하여 단일 최신 위치 정보를 저장.
    - TTL을 통해 주기적으로 갱신 및 비활성 사용자 자동 삭제.
- **클러스터 고려:**
    - 데이터가 여러 해시 슬롯에 분산되어 조회 시 네트워크 오버헤드가 발생할 수 있으나, 분산 조회로 개별 노드 부하는 감소.

### 위치 이동 이력 데이터베이스 (Cassandra)
- **목적:**
    - 사용자의 위치 변경 이력을 막대한 쓰기 부하에 견디며 저장.
- **일관성:**
    - 최종 일관성 모델로, 쓰기 후 데이터가 동기화되는 데 약간의 지연 허용.
- **샤딩:**
    - 사용자 ID 기반 샤딩 적용, 데이터 리밸런싱 최소화를 위한 전략 고려.

### 레디스 Pub/Sub
- **채널 관리:**
    - 각 사용자별 또는 지오해시 기반 채널로 구성.
    - 안정 해시를 이용해 분산된 레디스 Pub/Sub 서버에 채널 할당.
- **메시지 전파:**
    - 발행된 메시지는 구독 중인 웹소켓 서버로 전파되며, 해당 서버는 친구 간 거리를 다시 계산 후 전송 여부 결정.
- **비교:**
    - 레디스 Pub/Sub는 메시지 되감기가 불가능하므로, 메시지 재처리가 필요하면 Kafka 등의 메시지 버스를 고려할 수 있음.

---

## 5. 설계 고려사항 및 비교

### 위치 업데이트 전파
- **업데이트 주기:**
    - 사용자 1명이 30초마다 위치 전송 → 초당 334,000건의 업데이트.
- **메시지 전파:**
    - 한 사용자가 평균 400명의 친구 중 약 10%가 활성 상태이면,  
      초당 최대 334,000 × 400 × 10% ≈ 14,000,000 건의 위치 전파 가능.
- **대응:**
    - 대규모 트래픽 처리를 위해 분산 레디스 Pub/Sub 클러스터와 안정 해시 적용.

### 레디스 Pub/Sub vs. Kafka/MQ
- **레디스 Pub/Sub:**
    - 간단하고 빠른 메시지 전파, 다수의 구독자 관리 시 CPU 부하 고려.
    - 메시지 재처리(되감기)는 불가능.
- **Kafka/MQ:**
    - 메시지 내구성 및 재처리 기능 제공, 확장성 우수.
    - 설정 및 관리 복잡도 증가.

### 샤딩 및 데이터 리밸런싱
- **샤딩 키 변경 시:**
    - 리밸런싱 대상만 추출하여 최소화하거나, 전체 데이터를 주기적으로 재분배하는 방식 검토.
    - 예를 들어, 최근 2달치 데이터만 보관하여 전체 데이터 규모 축소.
