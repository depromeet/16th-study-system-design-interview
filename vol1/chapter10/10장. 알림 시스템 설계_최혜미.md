# 알림 시스템 설계

## 1. 알림 시스템 
- 푸시 알림 ,SNS 메시지, 이메일 알림 지원
- 연성실시간 시스템
- IOS단말, 안드로이드, 데스크톱/랩톱 지원
- 알람 받지 않기 설정 가능
- 모바일 : 천만건 / SMS : 백만건 / 이메일 : 5백만건

---

## 2. 초기 설계와 문제점

### 초기 설계
- **알림 요청:**  
  각 서비스(마이크로서비스, 크론잡 등)가 알림 시스템 API를 호출하여 요청 전달
- **알림 전송:**  
  알림 시스템은 요청을 받아 제3자 서비스(APNS, FCM, SMS 제공업체, 이메일 서비스)로 실제 알림 전송을 위임

### 문제점
- **SPOF**
    - 알림 전송 담당 단일 서버 또는 구성 요소에 장애 발생 시 전체 시스템 장애 가능
- **확장성 문제**
    - DB, 캐시, 알림 서버가 한 곳에 집중되어 부하 집중 및 성능 병목 우려
- **사용자 설정 관리 문제**
    - 사용자별 알림 설정, 전송률 제한, 중복 전송 방지 등 세밀한 관리 어려움

---

## 3. 개선된 설계안

### 3.1 시스템 구성 요소 분리 및 역할

- **알림 서버**
    - **알림 전송 API:**  
      외부 서비스가 인증된 API를 통해 알림 요청을 할 수 있도록 제공
    - **알림 검증 및 사용자 설정 조회:**  
      사용자 정보, 알림 내용, 알림 설정(예: 전송률 제한) 검증
    - **알림 데이터 처리:**  
      DB 및 캐시에서 필요한 데이터를 조회하여 알림 페이로드 구성
    - **메시지 큐 연동:**  
      알림 데이터를 MQ에 기록하여 비동기적으로 작업 서버에 전달

- **메시지 큐**
    - 각 채널별 독립된 큐 사용
    - 장애 격리 및 독립적 재시도 처리 지원
    - 시스템 구성 요소 간 의존성 감소

- **작업 서버**
    - MQ로부터 알림 이벤트를 소비하여 제3자 서비스(APNS, FCM, SMS, 이메일)로 실제 알림 전송
    - 전송 실패 시 재시도 로직 수행 및 이벤트 ID를 통한 중복 전송 방지 (예: Bloom filter 활용)

- **데이터베이스 & 캐시**
    - 사용자 정보, 알림 로그, 알림 설정 등을 저장
    - 캐시 서버를 통해 읽기 부하 감소 및 I/O 성능 최적화
    - 데이터 압축 및 캐싱 전략을 통해 네트워크 및 CPU 리소스 효율화

### 3.2 전송 및 처리 흐름

1. **알림 요청 접수:**  
   다양한 서비스가 알림 시스템 API를 호출하여 요청 전달

2. **검증 및 데이터 조회:**  
   알림 서버에서 사용자 정보, 알림 설정, 템플릿 등을 캐시/DB에서 조회하여 검증

3. **메시지 큐에 이벤트 등록:**  
   알림 전송 이벤트를 MQ에 기록하여 비동기 처리

4. **알림 전송:**
    - 작업 서버가 큐를 소비하여 각 채널(APNS/FCM, SMS 제공업체, 이메일 서비스)로 알림 페이로드 전송
    - 전송 결과에 따라 성공/실패 로그 기록 및 재시도 로직 수행

5. **모니터링 및 이벤트 추적:**  
   전송률, 큐 지연, 알림 확인/클릭율 등 다양한 지표를 모니터링하여 시스템 상태 및 사용자 반응 분석

---

## 4. 추가 고려사항 및 보완점

### 4.1 데이터 안정성 및 중복 전송 방지

- **데이터 손실 방지**
    - 알림 데이터를 DB에 저장하고, MQ에 기록하여 장애 상황에서도 재시도 가능하도록 설계
    - 재시도 시 전송 이벤트의 고유 ID를 확인하여 중복 전송 방지 (예: Bloom filter 도입 검토)
- **알림 중복 전송 방지**
    - 한 번 전송된 알림의 이벤트 ID를 로그에 기록하여 중복 확인
    - 분산 환경에서 임시적 중복 경고 후 재시도 가능하도록 설계

### 4.2 사용자 설정 및 전송률 제한

- **알림 설정 관리**
    - 사용자 opt-in/opt-out 설정, 채널별 알림 수신 여부, 알림 템플릿 등을 DB에 저장하여 유연하게 관리
    - 설정 변경 시 실시간 반영을 위한 캐시와 DB 간 동기화 고려
- **전송률 제한**
    - 사용자가 너무 많은 알림을 받지 않도록 전송률 제한 기능 구현
    - 채널별/사용자별 전송 빈도, 시간 단위 최대 전송 건수 적용하여 스팸성 알림 예방

### 4.3 확장성 및 장애 격리

- **수평 확장**
    - 알림 서버, DB, 캐시, MQ 등 각 구성 요소를 분리하여 수평 확장이 가능하도록 설계
    - 클라우드 환경에서 자동 스케일 아웃 고려
- **장애 격리**
    - 각 알림 채널별로 독립된 큐 또는 토픽 사용하여 한 채널의 장애가 다른 채널에 영향을 주지 않도록 분리
    - 제3자 서비스 장애 시 별도 재시도 로직 및 백오프(back-off) 전략 적용
- **모니터링 및 알림**
    - MQ 큐 길이, 전송 성공률, 실패율 등 주요 지표를 모니터링
    - 장애 발생 시 개발자 또는 운영팀에 즉각적인 알림 제공

### 4.4 보안 및 인증

- **보안 강화**
    - 모바일 푸시의 경우 appKey, appSecret 등을 통한 인증 및 권한 관리
    - API 호출 시 인증된 클라이언트만 요청할 수 있도록 OAuth 또는 API 키 기반 인증 적용

### 4.5 템플릿 관리 및 이벤트 추적

- **알림 템플릿**
    - 공통 템플릿을 정의하여 매번 메시지를 새로 생성하지 않고 템플릿 기반으로 알림 내용 구성
    - 템플릿 버전 관리 및 사용자별 커스터마이징 고려
- **이벤트 추적 및 분석**
    - 알림 확인률, 클릭률, 실제 앱 사용 연동 등 이벤트를 상세히 추적하여 사용자 반응 분석
    - A/B 테스트 등 데이터 기반 최적화 전략 수립

---

## 5. 결론 및 최종 정리

### 핵심 목표
- 높은 확장성, 안정성, 사용자 맞춤형 전송 기능을 갖춘 알림 시스템 구축
- 다양한 채널(모바일 푸시, SMS, 이메일)을 유연하게 통합

### 주요 설계 요소
1. **채널 별 특성 고려**
    - iOS/Android 푸시, SMS, 이메일 등 각 채널의 특징에 맞는 전송 방식 및 보안 적용
2. **분산 및 비동기 처리**
    - MQ를 통한 비동기 처리, 작업 서버 분리, DB와 캐시 분리로 SPOF 방지
3. **재시도 및 모니터링**
    - 전송 실패 시 자동 재시도, 큐 및 이벤트 추적으로 시스템 상태 모니터링
4. **사용자 설정 및 전송률 제한**
    - 사용자가 원치 않는 알림을 받지 않도록 세밀한 설정과 제한 기능 제공

### 추가 고려점 및 보완점
- **트래픽 및 부하 테스트:**  
  대규모 알림 전송 시 병목 현상, 처리량 시뮬레이션 및 실제 환경에서 성능 튜닝 필요
- **장애 복구 시나리오:**  
  제3자 서비스 장애, 네트워크 문제 등 예외 상황에 대비한 복구 프로세스 구체화
- **동적 사용자 설정 반영:**  
  사용자별 알림 선호도 및 설정 변경이 실시간 반영될 수 있도록 캐시 무효화 및 데이터 동기화 전략 보완
- **통합 모니터링 및 분석 도구:**  
  여러 채널에서 발생하는 이벤트와 로그를 통합 분석할 수 있는 시스템 마련 필요
