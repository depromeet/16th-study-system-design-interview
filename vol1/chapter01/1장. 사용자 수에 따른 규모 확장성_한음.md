## 1장 사용자 수에 따른 규모 확장성

- 천리 길도 한 걸음 부터 <br>
- **단일 서버**로 구성된 시스템부터 설계해보자

---
### **AS-IS**
- 웹 앱, DB, 캐시 등이 전부 한 서버에 있다.
 - 사용자가 늘어나면 이 구조는 여러 문제를 초래하는데 
   - (1) **서버 장애 시 모든 서비스 중단**: 한 서버에서 모든 것을 처리하므로, 서버가 죽으면 전체 서비스가 중단된다.
   - (2) **리소스 공유로 인한 병목 현상**: 웹 앱, DB, 캐시가 동일한 리소스를 공유하므로 성능 저하가 발생할 수 있다.
   - (3) **기타 문제**: 확장성 부족, 단일 장애점(SPOF) 등.

### **TO-BE**
- 대안으로 서버를 분리해보자. 
- 웹 서버, DB 서버를 분리하여 독립적으로 운영하면
  - (1) **독립적 확장 가능**: 각 서버를 별도로 확장하여 트래픽 증가에 유연하게 대처할 수 있다.
  - (2) **리소스 분리로 병목 현상 감소**: 서로 다른 서버에서 리소스를 분리하여 효율적으로 운영할 수 있다.


- **DBMS 선택 고민**
    - 프로젝트의 요구사항에 따라 적합한 DBMS를 선택하자
      - **RDBMS**: 관계형 데이터베이스
      - **NoSQL**: 비관계형 데이터베이스 

---

- **운 좋게도 우리 서비스의 사용자가 급증했다.**
- 따라서 높은 트래픽을 감당하기 위해 서버를 확장해야 한다.
- **수직적 확장**과 **수평적 확장**을 고려해보자.

### **수직적 확장(scale up)**
- 서버에 CPU, 메모리, 디스크 등의 리소스를 추가하여 성능을 향상시키는 방법이다
- **장점**
  - **단순**: 기존 서버에 리소스를 추가하는 것이므로 비교적 간단하다.
- **단점**
  - **한계**: 한 대의 서버에 CPU나 메모리를 무한대로 증설할 수 없다.
  - **장애**: 서버 장애 시 전체 서비스가 중단된다.
- 이러한 단점 때문에 대규모 애플리케이션을 지원할 때는 **수평적 확장**을 고려해야 한다.

### **수평적 확장(scale out)**
- 여러 대의 서버를 추가하여 성능을 향상시키는 방법이다.
- **장점**
  - **확장성**: 서버를 추가하여 트래픽 증가에 유연하게 대처할 수 있다.
  - **고가용성**: 서버 장애 시 전체 서비스가 중단되지 않는다.
- **단점**
  - **관리 복잡성**: 여러 대의 서버를 관리해야 하므로 복잡해진다.

---

### **AS-IS**
- 서버를 확장하고, DB를 분리하여 별도의 서버로 운영하였다.
- 그러나 이 설계에서 사용자는 웹 서버에 직접 접근하므로, **웹 서버의 부하가 커질 수 있다.**
- 만약 웹 서버가 죽으면, 사용자는 서비스를 이용할 수 없게 된다.

### **TO-BE**
- **로드 밸런서**를 도입하여 사용자의 요청을 여러 대의 웹 서버로 분산시키자.
- **장점**
  - **부하 분산**: 장애를 자동 복구하지 못하는 문제(no failover)를 해결할 수 있다.
  - **고가용성**: 서버1이 죽으면 모든 트래픽은 서버2로 이동하여 서비스가 중단되지 않는다.
- 만약 두 대의 서버로 트래픽을 감당할 수 없다면, 서버를 더 추가하기만 하면 된다.

---

- 이제 웹 계층은 괜찮아 보이는데 DB 계층은 어떨까?
- 현재 설계에서 DB는 단일 서버에만 존재한다.
- 데이터베이스 다중화는 이런 문제를 해결할 수 있다.

### **데이터베이스 다중화**
- 보통은 **마스터-슬레이브 구조**로 구성한다.
  - **마스터**: 쓰기 작업을 담당한다.
  - **슬레이브**: 읽기 작업을 담당한다.
- 대부분의 애플리케이션은 읽기 작업이 많기 때문에, 슬레이브를 여러 대 두어 읽기 성능을 향상시키자
- **장점**
  - **성능 향상**: 병렬 처리될 수 있는 질의가 많아지므로 읽기 성능이 향상된다.
  - **안정성**: 자연 재해 등의 이유로 DB 서버 하나가 죽어도 다른 서버가 있으므로 서비스가 중단되지 않는다.
  - **가용성**: 데이터를 여러 지역에 복제해 두기 때문에 장애가 발생하더라도 계속 서비스를 제공할 수 있다.
- 만약 쓰기 작업을 담당하는 마스터 DB가 죽으면, 슬레이브 중 하나를 마스터로 승격시키면 된다.

---

- 지금 설계에서는 웹 페이지를 새로고침 할 때마다 한 번 이상의 데이터베이스 쿼리를 실행한다.
- 애플리케이션의 성능은 데이터베이스 성능에 크게 의존한다.
- 이러한 문제를 해결하기 위해 **캐시**를 도입해보자.

### **캐시**
- **캐시**는 데이터를 저장해두었다가 필요할 때 빠르게 제공하는 임시 저장소이다.
- 캐시 서버는 어떻게 동작할까? 우선 읽기 전략을 살펴보자
  - **캐시 미스**: 캐시에 데이터가 없는 경우, DB에서 데이터를 가져와 캐시에 저장한다.
  - **캐시 히트**: 캐시에 데이터가 있는 경우, 캐시에서 데이터를 가져온다.

- 캐시 사용시 유의할 점
  - 캐시 서버가 재시작되면 캐시가 초기화된다. 따라서 중요한 데이터는 DB에 저장하자.
  - 만료된 데이터는 캐시에서 삭제하자. 그리고 만료 기간은 적절히 설정하자. 
  - 캐시 서버를 한 대만 두면 SPOF가 발생할 수 있으므로 여러 대의 캐시 서버를 두자.
  - 캐시 메모리가 너무 작으면 데이터가 자주 삭제되므로 캐시 메모리를 과할당하자
  - 캐시가 꽉 차버리면 어떻게 할까? LRU(Least Recently Used) 등의 알고리즘을 사용하여 캐시에서 삭제할 데이터를 선정하자.

---

### **콘텐츠 전송 네트워크(CDN)**
- 정적 콘텐츠 전송을 위해 **콘텐츠 전송 네트워크(CDN)**를 도입해보자.
  - CDN은 전 세계에 분산된 서버에 콘텐츠를 저장해두고, 사용자가 요청할 때 가장 가까운 서버에서 콘텐츠를 제공한다.
  - CDN을 사용하면 콘텐츠 전송 속도가 빨라지고, 서버 부하가 줄어든다.
- CDN 사용 시 유의사항
  - CDN은 전송 양에 따라 요금이 부과된다. 따라서 자주 사용되지 않는 콘텐츠는 CDN에 저장하지 않는 것이 좋다.
  - CDN은 캐시 서버와 마찬가지로 데이터가 변경되면 즉시 반영되지 않을 수 있다. 따라서 콘텐츠가 자주 변경되는 경우 CDN을 사용하지 않는 것이 좋다.
  - CDN이 죽었을 경우, 해당 문제를 감지하여 대응할 수 있는 방안을 마련해두자.

---

- 이제 웹 계층을 수평적으로 확장하는 방법을 고려해볼 차례다
- **무상태(stateless) 웹 계층**을 도입해보자.
- **무상태(stateless) 웹 계층**이란, 사용자의 상태를 서버에 저장하지 않고, 모든 정보를 요청마다 전달하는 방식이다.

### **무상태(stateless) 웹 계층**
- 상태 정보에 의존적이지 않은, 무상태 아키텍처는 사용자의 요청을 처리하는 서버를 어떤 서버든 사용할 수 있게 한다.
- 상태 정보가 필요한 경우 공유 저장소로부터 상태 정보를 가져온다.
- 공유 저장소는 NoSQL, RDBMS, 캐시 등을 사용할 수 있다.

---

- 웹사이트가 매우 빨리 성장하여 전세계 어디서나 쾌적하게 서비스를 제공해야 한다.
- 이를 위해 **데이터 센터**를 도입해보자.

### **데이터 센터**
- 데이터 센터는 서버, 네트워크, 저장소 등을 한 곳에 모아둔 시설이다.
- 데이터 센터를 사용하면 서버를 물리적으로 분산하여 서비스를 안정적으로 제공할 수 있다.
- **장점**
  - **지리적 라우팅**: 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터에서 서비스를 제공받을 수 있다.
  - **장애 대응**: 한 데이터 센터에서 장애가 발생하면 다른 데이터 센터로 트래픽을 이동시켜 서비스를 계속 제공할 수 있다.
- 단, 몇가지 기술적 난제가 있다
  - **트래픽 우회**: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 한다.
  - **데이터 동기화**: 여러 데이터 센터에 데이터를 동기화하는 방법을 찾아야 한다.
  - **테스트와 배포**: 여러 데이터 센터에 서비스를 배포하고 테스트하는 방법을 찾아야 한다.

---

- 이제 메시지 큐를 도입하여 서비스의 확장성을 높여보자.

### **메시지 큐**
- **메시지 큐**는 서버 간의 비동기 통신을 위한 시스템이다.
- 메시지 큐를 사용하면 서버 간의 결합도를 낮추고, 서버의 부하를 분산시킬 수 있다.
- 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 전송할 수 있고, 소비자는 메시지를 처리할 수 있을 때 메시지를 가져올 수 있다.

---

### **AS-IS**
- 소규모 웹사이트를 만들때는 로그를 파일에 저장하고, 서버에 접속하여 로그를 확인했다.
- 그러나 사용자가 급증하면 로그를 파일에 저장하는 것은 불가능하다.
- **로그, 메트릭 그리고 자동화**를 도입하여 서비스를 안정적으로 운영해보자.

### **TO-BE**
- **로그 모니터링**: 로그를 실시간으로 모니터링하여 서버의 상태를 확인하자.
- **메트릭 모니터링**: 서버의 CPU, 메모리, 디스크 사용량 등을 모니터링하여 서버의 상태를 확인하자.
- **자동화**: 빌드, 테스트, 배포 등의 작업을 자동화하여 개발 생산성을 높이자.

---

- 이제 데이터베이스의 규모 확장을 고려해보자.
- 데이터베이스의 규모 확장은 **수직적 확장**과 **수평적 확장**을 고려해야 한다.
- **수직적 확장**은 DB 서버에 CPU, 메모리, 디스크 등의 리소스를 추가하는 방법이다.
- 단, 수직적 확장의 경우 CPU나 메모리를 무한대로 증설할 수 없다는 한계가 있다.
- 또한 SPOF가 발생할 수 있다.

### **수평적 확장**
- DB의 수평적 확장은 샤딩(sharding)이라고도 부른다.
- **샤딩**은 데이터를 여러 서버에 분산하여 저장하는 방법이다.
- **사용예시**
  - 샤드로 분할된 데이터베이스에 유저 정보를 저장한다.
  - 사용자 데이터를 어느 샤드에 넣을지는 사용자 ID에 따라 정한다
  - userId % 4를 해시 함수로 사용하여 4개의 샤드 중 하나를 선택한다.

- 샤딩 전략 구현 시 중요한 것
  - **샤딩 키**: 어떤 기준으로 데이터를 샤딩할지 결정하는 것이다.
  - **데이터의 재샤딩**: 샤딩 키를 변경하거나 샤드를 추가할 때 데이터를 재분배하는 작업이다.
  - **유명인사 문제**: 핫스팟 키 문제라고도 부르는데 특정 키에 대한 쿼리가 많이 발생하여 특정 샤드에 부하가 집중되는 문제이다.
  - **조인과 비정규화**: 여러 샤드에 걸친 데이터를 조인하기는 힘들다. 따라서 비정규화를 통해 하나의 테이블에서 질의가 수행되도록 하자

---