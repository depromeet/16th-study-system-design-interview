# 2장. 주변 친구
## 목표
'주변 친구'라는 모바일 앱 기능을 지원하는 규모 확장 용이한 백엔드 시스템을 설계하라.
## 1단계. 문제 이해 및 설계 범위 확정
- '주변'의 기준: 5 mile, 설정 가능한 수치, 직선 거리로 가정
- 사용자 수: 10억명, 기능 사용자 10%
- 사용자 이동 이력 보관 여부: 보관, 기계 학습 등 다양한 용도로 사용
- 친구 관계인 사용자가 10분 이상 비활성 상태일 경우 처리 방법: 주변 친구 목록에서 제거
- GDPR, CCPA 같은 사생활 및 데이터 보호법 고려 여부: 우선 생략
### 기능 요구사항
- 모바일 앱에서 주변 친구 확인
  - 해당 친구까지의 거리, 마지막으로 갱신된 시각 함께 표시
- 친구 목록은 n초마다 갱신
### 비기능 요구사항
- 낮은 지연 시간: 주변 친구 위치 변화 반영이 느리지 않아야 한다.
- 안정성: 시스템 전반적으로 안정적, 몇 개 데이터 유실 정도는 용인 가능
- 결과적 일관성: 위치 데이터 저장 위해 강한 일관성 지원하는 저장소 사용 불필요, 복제 지연 어느 정도 용인 가능
### 개략적 규모 추정
- 주변 친구 == 8km 반경 이내 친구
- 30초 주기로 갱신: 사람이 걷는 속도 = 4~6km/h 일 때, 30초 정도 이동은 주변 친구 검색 결과 변화가 미미
- 기능 사용자 DAU 1억 명
- 동시 접속자 수 = DAU * 10% = 천만 명
- 한 사용자 당 친구 수 = 400명
- 페이지 당 20명의 주변 친구 표시
- 위치 정보 갱신 QPS = 천만 / 30 = 33400
## 2단계. 개략적 설계안 제시 및 동의 구하기
- 개략적 설계
- API 설계
- 데이터 모델
### 개략적 설계
- 메시지의 효과적 전송을 가능케 할 설계안을 만들어야 함
- 모든 친구에게 위치 정보를 push 해야함 -> 활성 상태인 근방 모든 친구와 항구적 통신 상태 유지해야 함
  - HTTP 프로토콜 부적합
- P2P 방식으로 해결 가능한 부분!
  - 하지만, 단말의 통신 연결 상태, 전력 상태 등이 안 좋을 수 있음
- 공용 백엔드를 앞단에 두자!
  - 모든 활성 상태 사용자의 위치 변화 내역 수신
  - 사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아서 해당 친구들의 단말로 변경 내역 전달
  - 두 사용자 사이의 거리가 임계치보다 먼 경우 전송 X
- 문제점
  - 큰 규모에 적용하기 쉽지 않다.
    - 동시 접속자가 천만 명일 때 모두가 자신의 위치 정보를 30초마다 갱신한다면 초당 334,000번 갱신 발생
    - 사용자 당 400명의 친구를 가지고, 그 중 10%가 인근에서 활성 상태라고 가정한다면, 33400 * 400 * 10% = 1400만 번 갱신 발생
    - 이러한 갱신 내역을 사용자 단말로 보내는 작업까지 해야함
#### 소규모 백엔드를 위한 설계안
<img alt="image" src="https://github.com/user-attachments/assets/aefdd580-13eb-4354-95c0-12db174c4e63">

- redis pub/sub 동작
  1. 웹소캣 서버로 수신한 위치 정보 변경 이벤트: 해당 사용자에게 배정된 채널에 발행
  2. 해당 채널의 구독자 == 해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러
  3. 모든 구독자가 호출됨
  4. 각 핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 거리 다시 계산
  5. 거리가 검색 반경 이내면 갱신 위치/시각을 웹소캣 연결을 통해 해당 친구의 클라이언트 앱으로 전송

### API 설계
- HTTP 요청: API 서버는 친구 추가/삭제/갱신 등의 작업 처리
- 웹소켓: 웹소켓 프로토콜로 위치 정보 변경 내역을 전송/수신
#### 서버 API
- 주기적인 위치 정보 갱신
  - 요청: 클라이언트는 위도/경도/시각 정보 전송
  - 응답: 없음
- 웹소켓 초기화 API
  - 요청: 클라이언트는 위도/경도/시각 정보 전송
  - 응답: 클라이언트는 본인 친구들 위치 데이터 수신
#### 클라이언트 API
- 갱신된 친구 위치 수신할 API
  - 응답: 친구 위치 데이터와 변경된 시각을 나타내는 타임스탬프
- 새 친구 구독 API
  - 요청: 웹소켓 서버는 친구 ID 전송
  - 응답: 가장 최근 위도, 경도, 시각 정보 전송
- 구독 해지 API
  - 요청: 웹 소켓 서버는 친구 ID 전송
  - 응답: 없음
### 데이터 모델
#### 위치 정보 캐시
- 주변 친구 기능을 사용하는 활성 상태 친구의 가장 최근 위치 보관

| key         | value            |
|-------------|------------------|
| 사용자 ID | 위도, 경도, 시각 |
- 위치 정보 저장에 DB를 사용하지 않는 이유
  - 현재 위치 보관
  - 주기적 갱신
  - 영속성을 보장할 필요 없는 데이터
  - 캐시 warm up까지 갱신 주기 n번의 데이터 놓치는 정도는 수용 가능
#### 위치 이동 이력 DB
- 쓰기 연산 부하 감당 가능하면서, 수평적 규모 확장이 가능한 데이터베이스
- 카산드라가 적합
- 대규모 이력 데이터 양 관리 위해서 샤딩 필요
  - 사용자 ID 기준
## 3단계. 상세 설계
### 중요 구성요소별 규모 확장성
#### API 서버
- CPU 사용률이나 부하, I/O 상태에 따라 auto-scaling
#### 웹소켓 서버
- 사용률에 따라 auto-scaling
- 단, **유상태 서버**이므로 기존 서버 제거 시 주의
  - 노드 실제로 제거 전에 기존 연결부터 종료
  - 로드 밸런서가 인식하는 노드 상태를 `연결 종료 중`으로 변경하여 새로운 웹소켓 연결 만들어지지 않도록 처리
  - 모든 연결 종료 시 서버 제거
#### 클라이언트 초기화
- 클라이언트는 기동 시 웹소켓 클러스터 내 서버 중 하나와 지속성 웹소켓 연결 수립
- 웹소켓 연결 초기화 시 클라이언트는 모바일 단말 위치 정보를 웹소켓 연결 핸들러에 전송하면 다음 작업 진행
  1. 위치 정보 캐시에 보관된 사용자 위치 갱신
  2. 연결 핸들러 내 변수에 위치 정보 저장
  3. 사용자 DB에서 모든 친구 정보 조회
  4. 위치 정보 캐시에 batch 요청 보내어 모든 친구의 위치 한 번에 조회
     - TTL은 비활성화 타임아웃 시간과 동일한 값으로 설정되어 있으므로, 비활성 친구 위치는 캐시에 없을 것
  5. 캐시에서 반환한 친구 위치 각각에 대해 사용자와의 거리 계산
     - 검색 반경 이내 친구의 정보를 웹소켓 연결을 통해 클라이언트에 반환
  6. 웹 소켓 서버는 각 친구의 레디스 서버 pub/sub 채널 구독
     - 채널 생성/구독 비용 저렴
     - 사용자는 친구의 활성화/비활성화 상태 관계 없이 모든 친구 채널 구독
     - 비활성화 상태인 친구의 pu/sub 채널 유지 위해 필요한 메모리 크기는 소량, CPU & I/O 미사용
  7. 사용자 현재 위치를 레디스 전용 채널을 통해 모든 친구에게 전송
#### 사용자 DB
- 사용자 상세 정보
- 친구 관계 데이터
- 사용자 ID 기준 샤딩으로 수평적 규모 확장
#### 위치 정보 캐시
- 각 항목의 키에 TTL 설정
  - 사용자 위치 정보 갱신마다 초기화
  - 최대 메모리 사용량은 일정 한도 아래로 유지
- 발생하는 갱신 연산 수: 30초 마다 갱신 시 초당 334,000회 발생
  - 사용자 ID 기준 샤딩으로 부하 분산
- 가용성: 각 샤드에 보관된 데이터를, standby 노드에 복제
  - 주 노드 장애 발생 시 대기 노드 승격하여 장애 시간 감소
#### 레디스 pub/sub 서버
- 모든 온라인 친구에게 보내는 위치 변경 내역 메시지의 **라우팅 계층**으로 활용
- 기능을 사용하는 모든 사용자에 채널 하나씩 부여
    - 기능 사용하는 사용자 앱은 초기화 시 모든 친구의 채널 구독
- 채널 생성 비용 저렴
- 구독자 없는 채널의 메시지 유기 시 서버 부하 거의 없음
- 채널 유지 위한 구독자 관계 추적용 해시 테이블 & 연결 리스트 메모리 사용량 적음
- 오프라인 사용자는 채널 있어도 CPU & I/O 미사용
#### 필요한 pub/sub 서버 수
- 메모리 사용량
  - 채널 수: 1억 개
  - 모든 채널 저장하기 위한 메모리: 200GB = 1억 * 20 byte * 100명 / 10^9
    - 한 사용자의 활성 친구 중 100명이 주변 친구 기능 사용한다고 가정
    - 구독자 한 명 추적 위한 내부 해시 테이블과 연결 리스트에 20byte 상당의 포인터 저장
  - 100GB 메모리 설치 가능한 최신 서버 사용 시, 모든 채널 보관 위한 레디스 pub/sub은 2대면 충분
- CPU 사용량
  - 위치 정보 업데이트: 초당 1400만 건
  - 기가비트 네트워크 카드 탑재한 서버 한대로 감당 가능한 구독자 수 10만으로 가정
  - 필요한 레디스 서버 수 = 1400만 / 10만 = 140대
- **레디스 펍/섭 서버의 병목은 메모리가 아닌 cpu 사용량**이다.
- 규모 감당 위해서는 **분산 레디스 펍/섭 클러스터** 필요
#### 분산 레디스 펍/섭 서버 클러스터
- 모든 채널은 서로 독립적: 메세지 발행 사용자 ID 기준 샤딩
- 매끄러운 운영 위해서는 장애 복구 전략 필요: **서비스 탐색 컴포넌트** 도입
  - ex) etcd, 주키퍼 등
  - 가용 서버 목록을 유지하는 기능 및 해당 목록을 갱신하는 데 필요한 UI나 API
    - 설정  데이터를 보관하기 위한 소규모 키-값 저장소 개념
      
      | key                  | value                        |
      |----------------------|------------------------------|
      | /config/pub_sub_ring | ["p_1", "p_2", "p_3", "p_4"]] |
  - 클라이언트(웹소켓 서버)가 "값"에 명시된 레디스 펍/섭 서버에서 발생한 변경 내역을 구독할 수 있는 기능
  - 레디스 펍/섭 서버는 메시지 발행할 채널이나 구독할 채널 정할 때 해시 링을 참조
  1. 웹소켓 서버는 해시 링 참조하여 메시지 발행할 레디스 펍/섭 서버를 선정
     - 정확한 정보는 서비스 탐색 컴포넌트에 보관
     - 성능 높이고 싶으면 해시 링 사본을 웹 소켓 서버에 캐싱: 단, 데이터 일관성 유의
  2. 웹소켓 서버는 해당 서버가 관리하는 사용자 채널에 위치 정보 변경 내역 발행
#### 레디스 펍/섭 서버 클러스터의 규모 확장 고려사항
- 유상태 서버 클러스터
  - 펍/섭 채널을 통해 처리되는 데이터는 무상태
    - 펍/섭 채널에 전송되는 메시지는 메모리나 디스크에 보관 X
    - 채널의 모든 구독자에게 전송 후 바로 삭제
    - 구독자가 없어도 삭제
  - 펍/섭 서버는 유상태 서버
    - 채널에 대한 상태 정보(채널 구독자 목록)를 보관
    - 특정 채널 담당하던 서버 교체 or 해시 링에서 제거 시 채널은 다른 서버로 이동 & 해당 채널의 모든 구독자에게 알려야 함
    - 기존 채널에 대한 구독 관계 해지 및 새 서버에 마련된 대체 채널 재구독
- 혼잡 시간대 트래픽을 무리 없이 감당하고 불필요한 크기 변화를 피할 수 있도록 어느 정도 여유를 두고 오버 프로비저닝
- 그럼에도 규모 확장이 필요하다면 다음을 유의
  - 클러스터 크기 조정 시 해시 링 위 서버 재조정 필요
    - 서비스 탐색 컴포넌트가 모든 웹소켓 서버에 해시 링 갱신을 알리면 엄청난 재구독 요청 발생
  - 재구독 요청 처리 시 클라이언트가 보낸 위치 정보 변경 메시지 처리 누락 가능
    - 손실 일부 허용하긴 하지만, 그 빈도는 반드시 최소화
  - 서비스 상태 불안정해질 가능성 있으므로, 클러스터 크기 조정은 트래픽 가장 낮은 시간에 수행
- 클러스터 크기 조정 방법
  - 새로운 링 크기 계산
  - 해시 링의 키에 달란 값을 갱신
  - 대시보드 모니터링: 웹소켓 클러스터의 CPU 사용량이 어느 정도 튀는가
#### 운영 고려사항
- 레디스 펍/섭 서버 교체: 교체되는 서버의 채널만 조정
- 서버 장애는 발생하고, 그런 서버는 일상적으로 교체해야 함
- 장애 발생 시, on-call 엔지니어에게 경보 발송하여 담당자가 장애 발생한 노드를 대기 노드와 교체
  - 각 웹소켓 서버는 실행 중인 연결 핸들러에게 새 펍/섭 서버의 채널을 구독하도록 알림
  - 각 연결 핸들러는 구독 중인 채널 목록 유지하고 있으므로, 모든 채널을 대조하여 구독 관계 재설정해야하는지 검토
### 친구 추가/삭제
- 새 친구 추가: 해당 클라이언트에 연결된 웹소켓 서버의 연결 핸들러에 알려 채널 구독
- 새 친구 추가되면 호출할 콜백을 등록
  - 콜백 호출 시 웹소켓 서버에 채널 구독 메시지 전송
- 친구 삭제: 호출될 콜백 등록하여 채널 구독 취소 메시지를 웹소켓 서버로 전송
### 친구가 많은 사용자
- 친구 관계는 양방향, 최대 친구 수 상한 존재 가정
- 수천 명 친구 구독에 필요한 펍/섭 구독 관계는 여러 웹소켓 서버에 분산: 핫스팟 문제 발생 X
- 특정 서버에 막대한 부담을 줄 일 없음
### 주변의 임의 사용자
#### 위치 정보 공유에 동의한 주변 사용자를 무작위로 보여준다면?
- 지오 해시에 따라 구축된 펍/섭 채널 풀을 배치
- 해당 격자 내 모든 사용자는 격자 내 채널을 모두 구독
- 경계 부근 사용자 처리 위해 위치한 지오해시 외 주변 지오해시 격자 채널도 구독
### 레디스 펍/섭 외의 대안
- 얼랭(Erlang): 고도로 분산된 병렬 애플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경
  - 경량 프로세스: BEAM VM에서 실행되는 개체
    - 얼랭 프로세스 생성 비용은 매우 저렴
    - 최신 서버 한 대로 수백만 프로세스 실행 가능
    - 아무 작업 하지 않는 얼랭 프로세스는 CPU 자원 전혀 소모 X
  - 여러 서버로 분산 용이
    - 운영 부담 낮음
    - 프로덕션에서 발생하는 이슈의 실시간 디버깅 지원
    - 배포 도구 강력
#### 현재 설계안에서는?
- 웹소켓 서비스를 얼랭으로 구현
- 레디스 펍/섭 클러스터는 분산 얼랭 애플리케이션으로 대체
  - 각 사용자 = 얼랭 프로세스
  - 사용자 프로세스는 클아이언트가 전송하는 갱신된 사용자 위치를 웹소켓 서버를 통해 수신
  - 친구 관계에 있는 사용자의 얼랭 프로세스와 구독 관계 설정 및 위치 변경 내역 수신
    - 얼랭/OTP는 구독 기능 내장
- 프로세스 사이의 연결망은 사용자 위치 변경 내역을 친구들에게 효과적으로 전파
## 4단계. 마무리
### 핵심 컴포넌트
- 웹소켓: 클라이언트와 서버 사이 실시간 통신 지원
- 레디스: 위치 데이터의 빠른 읽기/쓰기 지원
- 레디스 펍/섭: 사용자 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층